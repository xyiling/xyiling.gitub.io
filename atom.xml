<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xyl的个人博客</title>
  
  <subtitle>基本工资高才是福利，谈绩效的一律视为CPU</subtitle>
  <link href="https://github.com/xyiling/xyiling.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/xyiling/xyiling.github.io/"/>
  <updated>2024-09-06T03:53:55.187Z</updated>
  <id>https://github.com/xyiling/xyiling.github.io/</id>
  
  <author>
    <name>xiaoyiling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建python项目</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/09/06/%E6%90%AD%E5%BB%BApython%E9%A1%B9%E7%9B%AE/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/09/06/%E6%90%AD%E5%BB%BApython%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-09-06T03:25:47.616Z</published>
    <updated>2024-09-06T03:53:55.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟环境venv"><a href="#虚拟环境venv" class="headerlink" title="虚拟环境venv"></a>虚拟环境venv</h2><p>基于包管理和包版本，不同版本的包如果都放在全局目录，会导致不同的项目采用了相同版本的包，而一些项目只能用某个版本；<br>包放在全局目录，导致包污染，使用虚拟环境解决。</p><h2 id="创建并启用虚拟环境"><a href="#创建并启用虚拟环境" class="headerlink" title="创建并启用虚拟环境"></a>创建并启用虚拟环境</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv .venv</span><br><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br><span class="line"><span class="comment"># source .venv/bin/activate.fish # fish 和bash/zsh语法不同，因此有专门的脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">(.venv) xyl@VM-20-8-ubuntu ~/p/xtools&gt; <span class="built_in">which</span> pip</span><br><span class="line">/home/xyl/py/xtools/.venv/bin/pip <span class="comment"># 使用的是虚拟环境的 pip包管理器</span></span><br></pre></td></tr></table></figure><h2 id="poetry-包管理器"><a href="#poetry-包管理器" class="headerlink" title="poetry 包管理器"></a>poetry 包管理器</h2><p>pip的缺陷：安装包时可以把需要的其他依赖拉取下来，但删除时只删除一个。poetry可以解决这个问题</p><h3 id="poetry的命令"><a href="#poetry的命令" class="headerlink" title="poetry的命令"></a>poetry的命令</h3>]]></content>
    
    
    <summary type="html">搭建python项目</summary>
    
    
    
    <category term="python" scheme="https://github.com/xyiling/xyiling.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://github.com/xyiling/xyiling.github.io/tags/python/"/>
    
    <category term="服务器项目" scheme="https://github.com/xyiling/xyiling.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>grep、sed、awk与正则</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/08/26/grep%E3%80%81sed%E3%80%81awk%E4%B8%8E%E6%AD%A3%E5%88%99/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/08/26/grep%E3%80%81sed%E3%80%81awk%E4%B8%8E%E6%AD%A3%E5%88%99/</id>
    <published>2024-08-25T16:00:00.000Z</published>
    <updated>2024-08-26T07:06:02.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><h3 id="1-基础正则"><a href="#1-基础正则" class="headerlink" title="1. 基础正则"></a>1. 基础正则</h3><ol><li>grep命令支持基础正则。</li><li>grep命令后面跟’正则表达式’，操作的文件可以来自管道或文件。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -o <span class="string">&#x27;\([a-zA-Z]+\),&#x27;</span> regexp.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在regexp.txt中找出(aabf),类似内容</span></span><br></pre></td></tr></table></figure><h3 id="2-扩展正则"><a href="#2-扩展正则" class="headerlink" title="2.扩展正则"></a>2.扩展正则</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="补充概念"><a href="#补充概念" class="headerlink" title="补充概念"></a>补充概念</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;正则&quot;&gt;&lt;a href=&quot;#正则&quot; class=&quot;headerlink&quot; title=&quot;正则&quot;&gt;&lt;/a&gt;正则&lt;/h2&gt;&lt;h3 id=&quot;1-基础正则&quot;&gt;&lt;a href=&quot;#1-基础正则&quot; class=&quot;headerlink&quot; title=&quot;1. 基础正则&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络-物理层概念</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2024-08-09T16:00:00.000Z</published>
    <updated>2024-08-10T12:17:21.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、物理层概念总结"><a href="#一、物理层概念总结" class="headerlink" title="一、物理层概念总结"></a>一、物理层概念总结</h2><h3 id="1-信号、信源、信宿、码元、波特"><a href="#1-信号、信源、信宿、码元、波特" class="headerlink" title="1. 信号、信源、信宿、码元、波特"></a>1. 信号、信源、信宿、码元、波特</h3><p>信号：数据；</p><p>信源：信息发送方；</p><p>信宿：信息接收方；</p><p>码元：与电压跳变相关，参考<a href="###码元和比特">码元和比特</a></p><h3 id="2-传输速率"><a href="#2-传输速率" class="headerlink" title="2. 传输速率"></a>2. 传输速率</h3><h4 id="2-1-数据传输速率"><a href="#2-1-数据传输速率" class="headerlink" title="2.1 数据传输速率"></a>2.1 数据传输速率</h4><p>秒为单位，1kb/s=1000bits/s，k为1000（在存储领域，1kb=1024b）</p><h4 id="2-2-码元传输速率"><a href="#2-2-码元传输速率" class="headerlink" title="2.2 码元传输速率"></a>2.2 码元传输速率</h4><p>秒为单位，Baud/s</p><h3 id="3-编码和调制"><a href="#3-编码和调制" class="headerlink" title="3. 编码和调制"></a>3. 编码和调制</h3><h4 id="3-1-编码"><a href="#3-1-编码" class="headerlink" title="3.1 编码"></a>3.1 编码</h4><p>用于将数字或模拟信号编码成数字信号的技术。</p><ol><li><p>归零编码</p><p><strong>1先高后低，0一直都是低电平</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| 1 | 0 | 1 | 0 | 0 | 0 |</span><br><span class="line">+-----------------------+</span><br><span class="line"> -+      -+</span><br><span class="line">  +- ---  +- --- --- ---</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>非归零编码</p><p><strong>1为高电平，0为低电平</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| 1 | 0 | 1 | 0 | 0 | 0 |</span><br><span class="line">+-----------------------+</span><br><span class="line"> ---     ---</span><br><span class="line">     ---     --- --- ---</span><br></pre></td></tr></table></figure></li><li><p>反向归零编码</p><p><strong>0为高电平，1先低后高</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| 1 | 0 | 1 | 0 | 0 | 0 |</span><br><span class="line">+-----------------------+</span><br><span class="line">  +- ---  +-  --- --- ---</span><br><span class="line"> -+      -+ </span><br></pre></td></tr></table></figure></li><li><p>曼彻斯特编码</p><p><strong>1先高后低，0先低后高（或者相反）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| 1 | 0 | 1 | 0 | 0 | 0 |</span><br><span class="line">+-----------------------+</span><br><span class="line"> -+   +- -+   +-  +-  +-</span><br><span class="line">  +- -+   +- -+  -+  -+</span><br></pre></td></tr></table></figure></li><li><p>差分曼彻斯特编码</p><p>相同则<strong>不变电压</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| 1 | 0 | 1 | 0 | 0 | 0 |</span><br><span class="line">+-----------------------+</span><br><span class="line"> -+  -+  -+  -+   +- -+</span><br><span class="line">  +-  +-  +-  +- -+   +-</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-调制"><a href="#3-2-调制" class="headerlink" title="3.2 调制"></a>3.2 调制</h4><p>用于将数字信号或模拟信号编程模拟信号的技术</p><ol><li>调幅 调整 1 的表现方式，以非归零编码为例，原本1是直线，调幅后变成sin函数</li><li>调相 调整 1 和 0 的数值关系，如1是sinx，0是-sinx</li><li>调频 调整 1 和 0 的频率，通过不同的频率识别0和1</li><li>调幅+调频 4种幅度、4种频率，得到16种不同的码元，也就是需要$\log_{2}^{16}=4$bit来表示一个码元，如果码元传输速率是1Baud/s，那转换成比特传输速率则是4b/s。</li></ol><h3 id="4-数据交换网络"><a href="#4-数据交换网络" class="headerlink" title="4. 数据交换网络"></a>4. 数据交换网络</h3><h3 id="4-1-电路交换"><a href="#4-1-电路交换" class="headerlink" title="4.1 电路交换"></a>4.1 电路交换</h3><p>整体过程：建立连接—&gt;数据通信—&gt;释放连接</p><p>适用情况：数字信号、模拟信号；高实时性，大量数据</p><p>优点：数据按顺序发送和接收，高实时性，全双工</p><h3 id="4-2-报文交换"><a href="#4-2-报文交换" class="headerlink" title="4.2 报文交换"></a>4.2 报文交换</h3><ol><li><p>不建立通信链路，发送数据报文到路由表记录有的结点。</p></li><li><p>顺序不保证：发送“你吃饭我吃土。”，变成“你吃土我吃饭”。</p></li></ol><h3 id="4-3-分组交换"><a href="#4-3-分组交换" class="headerlink" title="4.3 分组交换"></a>4.3 分组交换</h3><ol><li><p>不建立通信链路，根据路由表发送到网络结点。</p></li><li><p>比报文交换一次性发送的数据量更小（通常128b），延迟更低，稳定性更高，信道利用率也更高。</p></li><li><p>顺序不保证：发送“你吃饭我吃土。”，变成“你吃土我吃饭”。</p></li></ol><h3 id="4-4-虚电路"><a href="#4-4-虚电路" class="headerlink" title="4.4 虚电路"></a>4.4 虚电路</h3><p>端到端建立一条多个结点的虚拟链路，一旦设备错误需要重新建立整条虚电路。</p><h2 id="二、物理层设备"><a href="#二、物理层设备" class="headerlink" title="二、物理层设备"></a>二、物理层设备</h2><ol><li><p>中继器</p><p>两台设备网络一致，可以使用不一致的物理信道。</p></li><li><p>集线器</p><p>多台设备网络一致，可以使用不一致的物理信道，<strong>机器越多网速越慢</strong>；</p><p>分割冲突域。</p></li></ol><h3 id="物理层协议"><a href="#物理层协议" class="headerlink" title="物理层协议"></a>物理层协议</h3><h2 id="三、补充概念"><a href="#三、补充概念" class="headerlink" title="三、补充概念"></a>三、补充概念</h2><h3 id="码元和比特"><a href="#码元和比特" class="headerlink" title="码元和比特"></a>码元和比特</h3><p>一个时间单位内电压变换种类，由此得到码元和比特的关系是bit=$\log_{2}^{k}$Baud</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、物理层概念总结&quot;&gt;&lt;a href=&quot;#一、物理层概念总结&quot; class=&quot;headerlink&quot; title=&quot;一、物理层概念总结&quot;&gt;&lt;/a&gt;一、物理层概念总结&lt;/h2&gt;&lt;h3 id=&quot;1-信号、信源、信宿、码元、波特&quot;&gt;&lt;a href=&quot;#1-信号、信源、信</summary>
      
    
    
    
    <category term="交换网络" scheme="https://github.com/xyiling/xyiling.github.io/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/"/>
    
    <category term="帧传输" scheme="https://github.com/xyiling/xyiling.github.io/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E4%BC%A0%E8%BE%93/"/>
    
    <category term="信号" scheme="https://github.com/xyiling/xyiling.github.io/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E4%BC%A0%E8%BE%93/%E4%BF%A1%E5%8F%B7/"/>
    
    <category term="编码" scheme="https://github.com/xyiling/xyiling.github.io/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E4%BC%A0%E8%BE%93/%E4%BF%A1%E5%8F%B7/%E7%BC%96%E7%A0%81/"/>
    
    <category term="调制" scheme="https://github.com/xyiling/xyiling.github.io/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E4%BC%A0%E8%BE%93/%E4%BF%A1%E5%8F%B7/%E7%BC%96%E7%A0%81/%E8%B0%83%E5%88%B6/"/>
    
    
    <category term="交换网络, 帧传输, 信号, 编码, 调制" scheme="https://github.com/xyiling/xyiling.github.io/tags/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C-%E5%B8%A7%E4%BC%A0%E8%BE%93-%E4%BF%A1%E5%8F%B7-%E7%BC%96%E7%A0%81-%E8%B0%83%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本学习笔记</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/08/05/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/08/05/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-08-04T16:00:00.000Z</published>
    <updated>2024-08-05T01:55:54.490Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2><ol><li>使用\$1、\$2…表示参数（这在脚本语言中称为位置参数），需要注意当参数个数超过10个（包括10），需要使用花括号，如${10}， 此外$0表示脚本或程序的名称；</li><li>使用$?表示上一条命令的执行返回值，0表示正常返回；</li><li>使用$#表示参数个数，$0将不被包含在内，即bash test.sh 0 1 2 3，使用echo $#将得到4，而不是5；</li><li>使用$$获取当前进程的进程号pid，如:93655；</li><li>使用\$@和\$*获取所有参数，其中\$*会将所有的参数当做一整个字符串，遍历时只会循环一遍；</li></ol><h2 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h2><ol><li>‘’单引号表示输出原始字符串，单引号内部的数据不会经过转义，但双引号””会；</li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol><li>$[1 + 1]、$((1 + 1))、expr 1 + 1 三种方式都可以进行四则运算；特殊地，expr四则运算的符号必须用空格隔开。</li><li>特殊地，*<em>表示乘方，如2*</em>3表示2^3=8；</li></ol><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ol><li>条件判断语句为[ ]，其中的符号包括：=（等于）、!=（不等于）、-z（字符串长度为零）、-n（字符串长度不为零）、-e（文件存在）、-f（文件存在且为普通文件）、-d（文件存在且为目录）、-r（文件存在且可读）、-w（文件存在且可写）、-x（文件存在且可执行）；</li><li>条件判断语句可以与&amp;&amp;（与）、||（或）、！（非）结合使用；</li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ol><li>for循环的语法为：for var in item1 item2… itemN；</li><li>while循环的语法为：while condition；</li><li>until循环的语法为：until condition；</li><li>break、continue语句用于跳出循环；</li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>函数的定义语法为：function name { commands; }；</li><li>函数调用语法为：name param1 param2…；</li><li>函数返回值使用return语句，返回值只能是数字、字符串、数组、字典等简单数据类型；</li></ol><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ol><li>输出到终端使用echo命令，如echo “Hello World!”；</li><li>输出到文件使用重定向符号&gt;，如echo “Hello World!” &gt; output.txt；</li><li>输入从终端使用read命令，如read name；</li><li>输入从文件使用&lt;符号，如cat input.txt | while read line; do echo $line; done；</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>数组的定义语法为：array_name=(item1 item2… itemN)；</li><li>数组的访问语法为：${array_name[index]}，其中index从0开始；</li><li>字典的定义语法为：declare -A dict_name=([“key1”]=”value1” [“key2”]=”value2”…)；</li><li>字典的访问语法为：${dict_name[“key”]}；</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>赋值不能空格，如a=1，不能写成a = 1；</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;参数处理&quot;&gt;&lt;a href=&quot;#参数处理&quot; class=&quot;headerlink&quot; title=&quot;参数处理&quot;&gt;&lt;/a&gt;参数处理&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用&#92;$1、&#92;$2…表示参数（这在脚本语言中称为位置参数），需要注意当参数个数超过10</summary>
      
    
    
    
    <category term="linux" scheme="https://github.com/xyiling/xyiling.github.io/categories/linux/"/>
    
    <category term="shell" scheme="https://github.com/xyiling/xyiling.github.io/categories/linux/shell/"/>
    
    
    <category term="shell" scheme="https://github.com/xyiling/xyiling.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和反序列化</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/08/01/java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/08/01/java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-08-01T09:03:14.430Z</published>
    <updated>2024-08-01T09:46:21.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><blockquote><p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程；</li><li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。</li></ul><p>对于 Java 这种面向对象编程语言来说，序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p><p>下面是序列化和反序列化常见应用场景：</p><ul><li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><h2 id="常见序列化协议"><a href="#常见序列化协议" class="headerlink" title="常见序列化协议"></a>常见序列化协议</h2><p>JDK自带的序列化方式一般不会用，因为序列化效率低并且存在安全问题。<br>比较常用的序列化协议有：Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。像<code>JSON</code>和<code>XML</code>这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p><h3 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a>JDK自带的序列化方式</h3><p>自带的序列化，只需实现 java.io.Serializable接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1905122041950251207L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="serialVersionUID-有什么作用"><a href="#serialVersionUID-有什么作用" class="headerlink" title="serialVersionUID 有什么作用"></a>serialVersionUID 有什么作用</h4><p>序列化号<code>serialVersionUID</code>属于版本控制的作用。反序列化时，会检查<code>serialVersionUID</code>是否和当前类的<code>serialVersionUID</code>一致。如果<code>serialVersionUID</code>不一致则会抛出<code>InvalidClassException</code>异常。强烈推荐每个序列化类都手动指定其<code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的<code>serialVersionUID</code>。</p><h4 id="serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？"><a href="#serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？" class="headerlink" title="serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？"></a>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</h4><p><code>static</code>修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，<code>serialVersionUID</code>是一个特例，<code>serialVersionUID</code>的序列化做了特殊处理。当一个对象被序列化时，serialVersionUID 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。如果两者不匹配，反序列化过程将抛出<code>InvalidClassException</code>，因为这通常意味着序列化的类的定义已经发生了更改，可能不再兼容。</p><h4 id="使用transient避免被序列化"><a href="#使用transient避免被序列化" class="headerlink" title="使用transient避免被序列化"></a>使用transient避免被序列化</h4><p><code>transient</code>只修饰变量。修饰的变量在序列化后的值都是对应类型的默认值，如int类型默认为0。</p><blockquote><p>static 变量不属于任何对象，不会被序列化</p></blockquote><h4 id="为什么不推荐使用Java自带的序列化工具？"><a href="#为什么不推荐使用Java自带的序列化工具？" class="headerlink" title="为什么不推荐使用Java自带的序列化工具？"></a>为什么不推荐使用Java自带的序列化工具？</h4><ul><li>不支持跨语言调用: 如果调用的是其他语言开发的服务的时候就不支持了。</li><li>性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li>存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序列化和反序列化&quot;&gt;&lt;a href=&quot;#序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化和反序列化&quot;&gt;&lt;/a&gt;序列化和反序列化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;序列化（serialization）在计算机科学的数据处理中，是指</summary>
      
    
    
    
    <category term="Java" scheme="https://github.com/xyiling/xyiling.github.io/categories/Java/"/>
    
    <category term="序列化" scheme="https://github.com/xyiling/xyiling.github.io/categories/Java/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>B+树概念</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/08/01/B+%E6%A0%91%E6%A6%82%E5%BF%B5/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/08/01/B+%E6%A0%91%E6%A6%82%E5%BF%B5/</id>
    <published>2024-07-31T16:00:00.000Z</published>
    <updated>2024-08-05T03:25:06.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-树概念"><a href="#B-树概念" class="headerlink" title="B+树概念"></a>B+树概念</h2><p>阶数m：分支数量，根据节点类型不同，m的取值不同。<br>对于非叶子结点，m&gt;=<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.258ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2766 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2308" d="M174 734Q178 746 190 750H298H369Q400 750 411 747T422 730T411 713T372 709Q365 709 345 709T310 710H214V-235Q206 -248 196 -250Q192 -250 189 -249T184 -247T180 -244T178 -241T176 -237T174 -234V734Z"></path></g><g data-mml-node="mi" transform="translate(444,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1322,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1822,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2322,0)"><path data-c="2309" d="M21 717T21 730T32 746T75 750H147H256Q266 742 269 735V-235Q262 -248 251 -250Q247 -250 244 -249T239 -247T235 -244T233 -241T231 -237T229 -234V710H133Q119 710 99 710T71 709Q43 709 32 713Z"></path></g></g></g></svg></mjx-container>,m&lt;=m-1。解释：一棵m阶b+树，非叶子结点最多含有m个分支（子结点），且最少含有m/2个分支（子结点）。<br>对于叶子节点，子结点数量最大可取m，最小还是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.258ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2766 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2308" d="M174 734Q178 746 190 750H298H369Q400 750 411 747T422 730T411 713T372 709Q365 709 345 709T310 710H214V-235Q206 -248 196 -250Q192 -250 189 -249T184 -247T180 -244T178 -241T176 -237T174 -234V734Z"></path></g><g data-mml-node="mi" transform="translate(444,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1322,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1822,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2322,0)"><path data-c="2309" d="M21 717T21 730T32 746T75 750H147H256Q266 742 269 735V-235Q262 -248 251 -250Q247 -250 244 -249T239 -247T235 -244T233 -241T231 -237T229 -234V710H133Q119 710 99 710T71 709Q43 709 32 713Z"></path></g></g></g></svg></mjx-container></p><p>m阶b+树，一个结点最多可以有m-1个关键字，最少<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.258ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2766 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2308" d="M174 734Q178 746 190 750H298H369Q400 750 411 747T422 730T411 713T372 709Q365 709 345 709T310 710H214V-235Q206 -248 196 -250Q192 -250 189 -249T184 -247T180 -244T178 -241T176 -237T174 -234V734Z"></path></g><g data-mml-node="mi" transform="translate(444,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1322,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1822,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2322,0)"><path data-c="2309" d="M21 717T21 730T32 746T75 750H147H256Q266 742 269 735V-235Q262 -248 251 -250Q247 -250 244 -249T239 -247T235 -244T233 -241T231 -237T229 -234V710H133Q119 710 99 710T71 709Q43 709 32 713Z"></path></g></g></g></svg></mjx-container>个关键字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B-树概念&quot;&gt;&lt;a href=&quot;#B-树概念&quot; class=&quot;headerlink&quot; title=&quot;B+树概念&quot;&gt;&lt;/a&gt;B+树概念&lt;/h2&gt;&lt;p&gt;阶数m：分支数量，根据节点类型不同，m的取值不同。&lt;br&gt;对于非叶子结点，m&amp;gt;=&lt;mjx-container </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java传值方式</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/08/01/java%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/08/01/java%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/</id>
    <published>2024-07-31T16:00:00.000Z</published>
    <updated>2024-08-05T03:22:12.423Z</updated>
    
    <content type="html"><![CDATA[<p>java 只支持值传递，没有引用传递方式，即使传入对象，那也是对象的地址，地址也是简单数据类型，也就是值传递，所以如果一个函数交换两个对象的地址，是不会成功的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">xiaoZhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">xiaoLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        swap(xiaoZhang, xiaoLi);</span><br><span class="line">        System.out.println(<span class="string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">temp</span> <span class="operator">=</span> person1;</span><br><span class="line">        person1 = person2;</span><br><span class="line">        person2 = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;person1:&quot;</span> + person1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;person2:&quot;</span> + person2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1:小李</span><br><span class="line">person2:小张</span><br><span class="line">xiaoZhang:小张</span><br><span class="line">xiaoLi:小李</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java 只支持值传递，没有引用传递方式，即使传入对象，那也是对象的地址，地址也是简单数据类型，也就是值传递，所以如果一个函数交换两个对象的地址，是不会成功的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="java" scheme="https://github.com/xyiling/xyiling.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/07/30/custom/css/background/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/07/30/custom/css/background/</id>
    <published>2024-07-30T10:25:11.749Z</published>
    <updated>2024-07-30T10:25:13.932Z</updated>
    
    <content type="html"><![CDATA[#web_bg {    background: -webkit-linear-gradient(      0deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );    background: -moz-linear-gradient(      0deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );    background: -o-linear-gradient(      0deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );    background: -ms-linear-gradient(      0deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );    background: linear-gradient(      90deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );  }  ]]></content>
    
    
      
      
    <summary type="html">#web_bg {
    background: -webkit-linear-gradient(
      0deg,
      rgba(247, 149, 51, 0.1) 0,
      rgba(243, 112, 85, 0.1) 15%,
      rgb</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/07/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/07/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</id>
    <published>2024-07-08T00:27:22.220Z</published>
    <updated>2024-07-12T06:34:54.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统概念整理"><a href="#操作系统概念整理" class="headerlink" title="操作系统概念整理"></a>操作系统概念整理</h1><h2 id="spooling技术"><a href="#spooling技术" class="headerlink" title="spooling技术"></a>spooling技术</h2><p>spooling技术是指将输入输出操作分离，将输入输出操作的请求存储在缓冲区中，并在需要时进行处理。</p><p>spooling技术的优点是：</p><ol><li>减少了系统的开销，因为不需要等待输入输出操作的完成。</li><li>提高了系统的并发性，因为可以同时处理多个输入输出操作。</li><li>简化了系统的设计，因为不需要考虑各种输入输出操作的细节。</li></ol><h2 id="覆盖交换技术"><a href="#覆盖交换技术" class="headerlink" title="覆盖交换技术"></a>覆盖交换技术</h2><ol><li>覆盖交换技术是指将内存中的程序和数据分割成多个区域，并在需要时进行交换。</li><li>覆盖交换技术的优点是：<ul><li>减少了内存的使用率，因为可以将程序和数据分割成多个区域，使得内存中有更多的空闲空间。</li><li>提高了内存的利用率，因为可以将程序和数据分割成多个区域，使得内存中有更多的程序和数据可以运行。</li><li>简化了内存管理，因为可以将程序和数据分割成多个区域，并在需要时进行交换，不需要考虑内存碎片的问题。</li></ul></li><li>覆盖交换技术的缺点是：<ul><li>增加了系统开销，因为需要进行内存的分配和交换。</li><li>降低了系统的并发性，因为交换操作需要暂停整个系统。</li></ul></li></ol><h2 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h2><ol><li>虚拟存储技术是指将一个物理存储器分割成多个逻辑存储器，并在需要时进行映射。</li><li>虚拟存储技术的优点是：<ul><li>减少了物理存储器的使用率，因为可以将物理存储器分割成多个逻辑存储器，使得物理存储器中有更多的空闲空间。</li><li>提高了物理存储器的利用率，因为可以将物理存储器分割成多个逻辑存储器，使得物理存储器中有更多的程序和数据可以运行。</li><li>简化了物理存储器管理，因为可以将物理存储器分割成多个逻辑存储器，并在需要时进行映射，不需要考虑物理碎片的问题。</li></ul></li><li>虚拟存储技术的缺点是：<ul><li>增加了系统开销，因为需要进行物理存储器的分配和映射。</li><li>降低了系统的并发性，因为映射操作需要暂停整个系统。</li></ul></li></ol><h2 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h2><ol><li>虚拟内存技术是指将物理内存分割成多个虚拟内存，并在需要时进行映射。</li><li>虚拟内存技术的优点是：<ul><li>减少了系统的开销，因为可以将物理内存分割成多个虚拟内存，使得系统中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>虚拟内存技术的缺点是：<ul><li>降低了物理内存的利用率，因为虚拟内存需要占用物理内存。</li><li>增加了物理内存的碎片，因为虚拟内存需要占用物理内存。</li></ul></li></ol><h2 id="通道技术"><a href="#通道技术" class="headerlink" title="通道技术"></a>通道技术</h2><ol><li>通道技术是指将输入输出操作分离，并通过专用通道进行传输。</li><li>通道技术的优点是：<ul><li>减少了系统的开销，因为不需要等待输入输出操作的完成。</li><li>提高了系统的并发性，因为可以同时处理多个输入输出操作。</li><li>简化了系统的设计，因为不需要考虑各种输入输出操作的细节。</li></ul></li><li>通道技术的缺点是：<ul><li>降低了系统的可靠性，因为通道可能会出现错误。</li><li>增加了系统的复杂性，因为需要设计专用通道。</li></ul></li></ol><h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><ol><li>缓冲技术是指将输入输出操作分离，并通过缓冲区进行传输。</li><li>缓冲技术的优点是：<ul><li>减少了系统的开销，因为不需要等待输入输出操作的完成。</li><li>提高了系统的并发性，因为可以同时处理多个输入输出操作。</li><li>简化了系统的设计，因为不需要考虑各种输入输出操作的细节。</li></ul></li><li>缓冲技术的缺点是：<ul><li>降低了系统的可靠性，因为缓冲区可能会出现错误。</li><li>增加了系统的复杂性，因为需要设计缓冲区。</li></ul></li></ol><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ol><li>页面置换算法是指当内存中没有空闲空间时，选择一页或多页页面进行替换。</li><li>页面置换算法的优点是：<ul><li>减少了系统的开销，因为可以将内存中的程序和数据分割成多个区域，使得内存中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>页面置换算法的缺点是：<ul><li>降低了系统的性能，因为频繁的页面置换会导致系统的响应时间变长。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h3 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h3><ol><li>最佳置换算法是指选择被访问最少的页面进行替换。</li><li>最佳置换算法的优点是：<ul><li>降低了系统的性能，因为可以减少页面置换的次数。</li><li>提高了系统的命中率，因为可以减少页面置换的次数。</li></ul></li><li>最佳置换算法的缺点是：<ul><li>降低了系统的并发性，因为需要等待被置换的页面被访问。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h3 id="最近最少使用置换算法"><a href="#最近最少使用置换算法" class="headerlink" title="最近最少使用置换算法"></a>最近最少使用置换算法</h3><ol><li>最近最少使用置换算法是指选择最近被访问的页面进行替换。</li><li>最近最少使用置换算法的优点是：<ul><li>降低了系统的性能，因为可以减少页面置换的次数。</li><li>提高了系统的命中率，因为可以减少页面置换的次数。</li></ul></li><li>最近最少使用置换算法的缺点是：<ul><li>降低了系统的并发性，因为需要等待被置换的页面被访问。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h3 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h3><ol><li>先进先出置换算法是指选择最先进入内存的页面进行替换。</li><li>先进先出置换算法的优点是：<ul><li>降低了系统的性能，因为可以减少页面置换的次数。</li><li>提高了系统的命中率，因为可以减少页面置换的次数。</li></ul></li><li>先进先出置换算法的缺点是：<ul><li>降低了系统的并发性，因为需要等待被置换的页面被访问。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h3 id="时钟置换算法"><a href="#时钟置换算法" class="headerlink" title="时钟置换算法"></a>时钟置换算法</h3><ol><li>时钟置换算法是指选择最近最久未使用页面进行替换。</li><li>时钟置换算法的优点是：<ul><li>降低了系统的性能，因为可以减少页面置换的次数。</li><li>提高了系统的命中率，因为可以减少页面置换的次数。</li></ul></li><li>时钟置换算法的缺点是：<ul><li>降低了系统的并发性，因为需要等待被置换的页面被访问。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><ol><li>虚拟内存管理是指管理虚拟内存，包括分配、映射、置换、回收等操作。</li><li>虚拟内存管理的优点是：<ul><li>减少了系统的开销，因为可以将物理内存分割成多个虚拟内存，使得系统中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>虚拟内存管理的缺点是：<ul><li>降低了物理内存的利用率，因为虚拟内存需要占用物理内存。</li><li>增加了物理内存的碎片，因为虚拟内存需要占用物理内存。</li></ul></li></ol><h2 id="虚拟内存的实现"><a href="#虚拟内存的实现" class="headerlink" title="虚拟内存的实现"></a>虚拟内存的实现</h2><ol><li>虚拟内存的实现是指将物理内存分割成多个虚拟内存，并在需要时进行映射。</li><li>虚拟内存的实现的优点是：<ul><li>减少了系统的开销，因为可以将物理内存分割成多个虚拟内存，使得系统中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>虚拟内存的实现的缺点是：<ul><li>降低了物理内存的利用率，因为虚拟内存需要占用物理内存。</li><li>增加了物理内存的碎片，因为虚拟内存需要占用物理内存。</li></ul></li></ol><h2 id="缓冲池技术"><a href="#缓冲池技术" class="headerlink" title="缓冲池技术"></a>缓冲池技术</h2><ol><li>缓冲池技术是指将内存中的程序和数据分割成多个区域，并在需要时进行缓冲。</li><li>缓冲池技术的优点是：<ul><li>减少了系统的开销，因为可以将程序和数据分割成多个区域，使得内存中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>缓冲池技术的缺点是：<ul><li>降低了物理内存的利用率，因为缓冲池需要占用物理内存。</li><li>增加了物理内存的碎片，因为缓冲池需要占用物理内存。</li></ul></li></ol><h2 id="虚拟内存与缓冲池的区别"><a href="#虚拟内存与缓冲池的区别" class="headerlink" title="虚拟内存与缓冲池的区别"></a>虚拟内存与缓冲池的区别</h2><ol><li>虚拟内存与缓冲池的区别是：<ul><li>虚拟内存是将物理内存分割成多个虚拟内存，并在需要时进行映射。</li><li>缓冲池是将内存中的程序和数据分割成多个区域，并在需要时进行缓冲。</li></ul></li></ol><h2 id="创建进程的四个情况"><a href="#创建进程的四个情况" class="headerlink" title="创建进程的四个情况"></a>创建进程的四个情况</h2><ol><li>用户登录</li><li>提供服务</li><li>作业调度</li><li>应用请求</li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统概念整理&quot;&gt;&lt;a href=&quot;#操作系统概念整理&quot; class=&quot;headerlink&quot; title=&quot;操作系统概念整理&quot;&gt;&lt;/a&gt;操作系统概念整理&lt;/h1&gt;&lt;h2 id=&quot;spooling技术&quot;&gt;&lt;a href=&quot;#spooling技术&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</id>
    <published>2024-07-07T10:43:48.235Z</published>
    <updated>2024-07-07T14:19:50.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构概念整理"><a href="#数据结构概念整理" class="headerlink" title="数据结构概念整理"></a>数据结构概念整理</h1><h2 id="如何通过c的数组实现hash操作？"><a href="#如何通过c的数组实现hash操作？" class="headerlink" title="如何通过c的数组实现hash操作？"></a>如何通过c的数组实现hash操作？</h2><p>给定一个数组长度为n，定义一个hash函数f(key) &#x3D; key % n，其中key为待查找的关键字。</p><p>通过hash函数计算出key对应的数组下标i，将数组下标i处的值置为key。</p><p>查找时，通过hash函数计算出key对应的数组下标i，并比较数组下标i处的值与key是否相等。如果相等，则说明查找成功；否则，说明查找失败。</p><p>如果要计算一个元素的个数，且在o(n)时间完成，就可以使用这个hash算法。   </p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>左根右，根叶黑，黑路同，不红红。</p><ul><li>左根右：左孩子 &lt; 根节点 &lt; 右孩子</li><li>根叶黑：根节点是黑色，叶子节点是黑色</li><li>黑路同：从任意节点到叶子节点的路径上，黑色节点数量相同</li><li>不红红：不会有红孩子的子节点还是红孩子</li></ul><p>红黑树有自平衡的机制，插入删除操作后，树的高度不会超过log(n)，也就意味着查找长度为O(log(n))。</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>哈夫曼树是一种二叉树，其中每个节点都是一个叶子节点或一个内部节点，且左右子树的权值之和最小。</p><p>哈夫曼树的生成过程：</p><ol><li>首先，将所有字符及其出现的频率作为叶子节点，构造一棵二叉树。</li><li>然后，从根节点开始，将两个权值最小的子树合并为一个新的内部节点，并将原来的两个子树作为左右子树。</li><li>重复步骤2，直到所有的叶子节点都在同一棵树上。</li></ol><h3 id="哈夫曼数的特性"><a href="#哈夫曼数的特性" class="headerlink" title="哈夫曼数的特性"></a>哈夫曼数的特性</h3><ul><li>任意一颗哈夫曼树都对应唯一的哈夫曼编码，且编码长度最短。</li><li>每一个编码都不能是其他编码的前缀。如0，10，110，1110，11110等。<br>  这样如果有一个编码：0 10 110 1110 </li><li>哈夫曼树的高度等于字符的个数。</li><li>哈夫曼树的平均路径长度等于字符的个数。</li></ul><h3 id="哈夫曼bergman编码"><a href="#哈夫曼bergman编码" class="headerlink" title="哈夫曼bergman编码"></a>哈夫曼bergman编码</h3><p>哈夫曼bergman编码是一种变长编码，它可以对任意长度的二进制串进行编码，且编码长度最短。</p><h3 id="哈夫曼编码的应用"><a href="#哈夫曼编码的应用" class="headerlink" title="哈夫曼编码的应用"></a>哈夫曼编码的应用</h3><ul><li>数据压缩：将原始数据经过哈夫曼编码后，编码后的串的长度通常比原始数据长度小很多。</li><li>数据加密：哈夫曼编码可以对数据进行加密，使得接收方无法直接解读数据内容。</li><li>数据校验：哈夫曼编码可以对数据进行校验，检测数据是否被篡改。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构概念整理&quot;&gt;&lt;a href=&quot;#数据结构概念整理&quot; class=&quot;headerlink&quot; title=&quot;数据结构概念整理&quot;&gt;&lt;/a&gt;数据结构概念整理&lt;/h1&gt;&lt;h2 id=&quot;如何通过c的数组实现hash操作？&quot;&gt;&lt;a href=&quot;#如何通过c的数组实现ha</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</id>
    <published>2024-07-07T10:22:13.179Z</published>
    <updated>2024-07-08T08:36:33.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理概念整理"><a href="#计算机组成原理概念整理" class="headerlink" title="计算机组成原理概念整理"></a>计算机组成原理概念整理</h1><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><h4 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h4><p>基础数据：12345678H</p><ul><li>大端：高位存放在低地址，和自然阅读的顺序一致，存放结果：12H 34H 56H 78H</li><li>小端：低位存放在低地址，和计算机数组的顺序一致，存放结果：78H 56H 34H 12H</li></ul><h2 id="bcd码"><a href="#bcd码" class="headerlink" title="bcd码"></a>bcd码</h2><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><p>BCD码是一种二进制编码，它将8位二进制数的低4位作为一个数字，高4位作为一个数字的进位。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成原理概念整理&quot;&gt;&lt;a href=&quot;#计算机组成原理概念整理&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理概念整理&quot;&gt;&lt;/a&gt;计算机组成原理概念整理&lt;/h1&gt;&lt;h2 id=&quot;存储器&quot;&gt;&lt;a href=&quot;#存储器&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/06/24/archlinux%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/06/24/archlinux%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93/</id>
    <published>2024-06-24T03:11:09.112Z</published>
    <updated>2024-08-05T03:28:02.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="archlinux安装总结"><a href="#archlinux安装总结" class="headerlink" title="archlinux安装总结"></a>archlinux安装总结</h1><h2 id="一、下载iso文件"><a href="#一、下载iso文件" class="headerlink" title="一、下载iso文件"></a>一、下载iso文件</h2><h2 id="二、校验签名"><a href="#二、校验签名" class="headerlink" title="二、校验签名"></a>二、校验签名</h2><p>通过http下载到的ISO镜像文件，很可能会受到故意的污染，带来潜在的威胁。</p><ol><li><p>安装<a href="https://wiki.archlinux.org/title/GnuPG">GnuPG</a></p><p>  GnuPG是一个完整的、免费的OpenPGP标准实现，支持对数据的加密和签名。</p></li><li><p><a href="https://mirrors.nju.edu.cn/archlinux/iso/2024.03.29/archlinux-2024.03.29-x86_64.iso.sig">下载签名</a></p><p>  校验签名</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.iso.sig</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、正式安装"><a href="#三、正式安装" class="headerlink" title="三、正式安装"></a>三、正式安装</h2><ol><li><p>关闭安全启动</p><p>  安装完成后可以重新开启安全启动。</p></li><li><p>设置控制台键盘和字体</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfont ter-132b <span class="comment"># archlinux控制台字体存放在/usr/share/kbd/consolefonts/，通过setfont fontname修改控制台点阵字体</span></span><br></pre></td></tr></table></figure></li><li><p>校验启动模式（UEFI、BIOS）</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/firmware/efi/fw_platform_size</span><br></pre></td></tr></table></figure><p>  如果返回64，代表运行在32位uefi模式环境下;如果返回32，代表运行在32位uefi环境下。只要支持uefi，BootLoader会使用systemd启动系统。</p><p>  如果文件不存在，代表当前环境可能是BIOS（或者说是csm）。</p><p>  如果两者都不是，那就要看看主板的手册了。</p></li><li><p>联网</p><ul><li><p>如果是局域网（wifi），需要保证网卡没有被关闭</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rfkill</span><br><span class="line">---------------------------------------</span><br><span class="line">ID TYPE      DEVICE      SOFT      HARD</span><br><span class="line"> 0 bluetooth hci0   unblocked unblocked</span><br><span class="line"> 1 wlan      phy0   unblocked unblocked</span><br></pre></td></tr></table></figure><p>如果HARD下是blocked（硬件级关闭），手动开启；</p><p>如果SOFT下是blocked（可以通过命令开启），使用<code>rfkill unblock wlan</code></p></li><li><p>使用<code>iwctl</code>命令联网</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iwctl</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">device list <span class="comment"># 显示可联网的设备列表</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设备关闭，使用下面的命令开启设备</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">device name set-property Powered on</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">adapter adapter set-property Powered on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扫描网络</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">station name scan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示扫描到的网络</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">station name get-networks</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接到指定网络</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">station name connect SSID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是有密码的wifi，使用下面的命令连接目标wifi</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iwctl --passphrase 密码 station 设备 connect SSID</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置系统时间<code>timedatectl</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure></li><li><p>分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk # 或者 fdisk -l</span><br></pre></td></tr></table></figure><p>需要以下的分区：</p><blockquote><ol><li>root分区 /</li><li>EFI分区（如果是多系统，使用已有的efi分区就行）</li><li>home分区</li><li>交换分区（交换文件，需要文件系统支持）</li></ol></blockquote><p>6.1 使用<code>cfdisk /dev/nvme0n1</code>对磁盘进行分区。</p><p>GPT格式各分区建议大小：</p><p>|   挂载点    |      分区       |       分区类型        |           分区大小            |<br>| :————-: | :——————-: | :—————————-: | :—————————————-: |<br>| <code>/mnt/boot</code> | <code>/dev/EFI分区</code>  | EFI system partition  |             1 GiB             |<br>|  <code>[SWAP]</code>   | <code>/dev/交换分区</code> |      Linux swap       |           至少4 GiB           |<br>|   <code>/mnt</code>    | <code>/dev/root分区</code> | Linux x86-64 root (/) | 剩余磁盘大小. 至少 23–32 GiB. |</p><p>6.2 格式化分区</p><p>root分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkfs.ext4 /dev/root_partition</span></span><br></pre></td></tr></table></figure><p>swap分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkswap /dev/swap_partition</span></span><br></pre></td></tr></table></figure><p>EFI分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkfs.fat -F 32 /dev/efi_system_partition</span></span><br></pre></td></tr></table></figure><p>6.3 挂载分区</p><p>挂载root分区到/mnt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount /dev/root_partition /mnt</span></span><br></pre></td></tr></table></figure><p>创建剩余的挂载点（如/mnt/boot），挂载其他分区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount --<span class="built_in">mkdir</span> /dev/efi_system_partition /mnt/boot</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">swapon /dev/swap_partition</span></span><br></pre></td></tr></table></figure></li><li><p>安装系统</p><p>7.1 换源</p><p>在<code>/etc/pacman.d/mirrorlist</code>文件中存放着各个区域对应的软件源。国内直接选出清华源、中科大源、南大源或其他高速源即可。</p><p>7.2 安装基本软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap -K /mnt base linux linux-firmware intel-ucode sof-firmware NetworkManager vim </span><br></pre></td></tr></table></figure><p>7.3 生成fstab文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>7.4 chroot（进入新系统）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>7.5 设置时区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;archlinux安装总结&quot;&gt;&lt;a href=&quot;#archlinux安装总结&quot; class=&quot;headerlink&quot; title=&quot;archlinux安装总结&quot;&gt;&lt;/a&gt;archlinux安装总结&lt;/h1&gt;&lt;h2 id=&quot;一、下载iso文件&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/06/24/gdb_debug/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/06/24/gdb_debug/</id>
    <published>2024-06-24T03:11:09.108Z</published>
    <updated>2024-07-08T08:31:30.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gdb指令"><a href="#gdb指令" class="headerlink" title="gdb指令"></a>gdb指令</h1><p>read memory: x &#x2F;nfu addr</p><p>n: how many elements to read.<br>f: how to display target data.<br>support format:</p><ul><li>x: data will be display in the form of hex code.</li><li>d: 0, 1, 2, …, nums like decimal.</li><li>u: unsigned int.</li><li>o: \0123, \0254, etc</li><li>t: binary</li><li>a: the same as ‘x’</li><li>i: addr</li><li>c: char</li><li>f: float<br>u: how many elements the addr counts.</li><li>b: 8 bit, 1 byte</li><li>h: 16 bits, 1 word</li><li>w: 32 bits, 2 words</li><li>g: 64 bits, 4 words</li></ul><p>for example:<br>x &#x2F;20cb 0x11223344: read memory address 0x11223344, data will be displayed in the stdout like a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,<br>x &#x2F;20ch 0x11223344: a,c,e,g,i,k,m,o,q,s</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gdb指令&quot;&gt;&lt;a href=&quot;#gdb指令&quot; class=&quot;headerlink&quot; title=&quot;gdb指令&quot;&gt;&lt;/a&gt;gdb指令&lt;/h1&gt;&lt;p&gt;read memory: x &amp;#x2F;nfu addr&lt;/p&gt;
&lt;p&gt;n: how many elements </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ostep笔记</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/06/24/ostep%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/06/24/ostep%E7%AC%94%E8%AE%B0/</id>
    <published>2024-06-24T03:11:09.108Z</published>
    <updated>2024-08-05T02:56:59.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter-1-进程"><a href="#Chapter-1-进程" class="headerlink" title="Chapter 1 进程"></a>Chapter 1 进程</h2><ol><li><p>进程的定义：运行着的程序<br>操作系统将存放在磁盘的程序加载到内存，将处理机资源分配给这些字节数据，程序就运行起来了。</p></li><li><p>CPU分时<br>操作系统会营造一种有着用不完的cpu的假象，使用的方法就是<strong>CPU分时</strong>技术。<br>什么是CPU分时技术？</p></li></ol><p>实现CPU分时技术的前提？</p><ul><li>需要cpu支持内核态和用户态机制。<blockquote><p>如【上下文切换技术】，该技术支持操作系统停下一个程序，去跑起另一个程序。需要保存要停止的程序的上下文内容，然后切换到另一个程序。</p></blockquote></li><li>需要操作系统支持一些调度算法。</li></ul>]]></content>
    
    
    <summary type="html">ostep读书小记</summary>
    
    
    
    <category term="OS" scheme="https://github.com/xyiling/xyiling.github.io/categories/OS/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</id>
    <published>2024-04-25T16:00:00.000Z</published>
    <updated>2024-08-26T07:06:15.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存置换策略"><a href="#内存置换策略" class="headerlink" title="内存置换策略"></a>内存置换策略</h3><h3 id="belady现象"><a href="#belady现象" class="headerlink" title="belady现象"></a>belady现象</h3><h2 id="CPU管理"><a href="#CPU管理" class="headerlink" title="CPU管理"></a>CPU管理</h2><h2 id="io管理"><a href="#io管理" class="headerlink" title="io管理"></a>io管理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h2&gt;&lt;h3 id=&quot;基本结构&quot;&gt;&lt;a href=&quot;#基本结构&quot; class=&quot;headerlink&quot; title=&quot;基本结构&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>rust学习笔记</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/04/17/rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/04/17/rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-16T16:00:00.000Z</published>
    <updated>2024-08-05T02:54:23.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="与其他后端语言的共性"><a href="#与其他后端语言的共性" class="headerlink" title="与其他后端语言的共性"></a>与其他后端语言的共性</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型（栈数据）"><a href="#基本数据类型（栈数据）" class="headerlink" title="基本数据类型（栈数据）"></a>基本数据类型（栈数据）</h4><ol><li><p>bool<br> true和false，大小为1个字节。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_true</span>: <span class="type">bool</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_false</span>: <span class="type">bool</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;is_true: &#123;&#125;&quot;</span>, is_true);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;is_false: &#123;&#125;&quot;</span>, is_false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>int</p><ul><li>i8：有符号8位整数类型</li><li>u8：无符号8位整数类型</li><li>i16：有符号16位整数类型</li><li>u16：无符号16位整数类型</li><li>i32：有符号32位整数类型</li><li>u32：无符号32位整数类型</li><li>i64：有符号64位整数类型</li><li>u64：无符号64位整数类型</li><li>i128：有符号128位整数类型</li><li>u128：无符号128位整数类型</li><li>isize：有符号指针大小整数类型</li><li>usize：无符号指针大小整数类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i8</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u16</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">i32</span> = -<span class="number">500</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span>: <span class="type">u64</span> = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b: &#123;&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;&#125;&quot;</span>, c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;d: &#123;&#125;&quot;</span>, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>float<br> f32和f64，遵从ieee754规则，f32是32位浮点数，f64是64位浮点数。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">f32</span> = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f64</span> = <span class="number">2.71828</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>char<br> Unicode标量值的32位表示。字符类型的大小为4个字节</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">char</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_emoji</span>: <span class="type">char</span> = <span class="string">&#x27;❤&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;&#125;&quot;</span>, c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;heart_emoji: &#123;&#125;&quot;</span>, heart_emoji);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h4><ol><li><p>元组（Tuple）<br> 将多个不同类型的值组合在一起。元组使用圆括号()表示，其中的值可以通过索引访问。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span>: (<span class="type">String</span>, <span class="type">i32</span>, <span class="type">bool</span>) = (<span class="string">&quot;Alice&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">25</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Name: &#123;&#125;&quot;</span>, person.<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Age: &#123;&#125;&quot;</span>, person.<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Is employed: &#123;&#125;&quot;</span>, person.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组（Array）</p><p> 数组是一种固定长度的数据结构，存储相同类型的多个值。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> numbers.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Number: &#123;&#125;&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>String，由一系列Unicode字符组成。可增长的。</p><p>以下是一个字符串的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Message: &#123;&#125;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><ol><li><p>结构体（Struct）<br> 将多个不同类型的值组合在一起形成一个新的类型。结构体使用struct关键字定义，并可以包含字段（field）和方法（method）。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Area: &#123;&#125;&quot;</span>, rect.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举（Enum）</p><p> 枚举是一种自定义的数据类型，它可以表示多个可能的值。枚举使用enum关键字定义，并可以包含不同的变体（variant）。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Banana,</span><br><span class="line">    Orange,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fruit</span>: Fruit = Fruit::Apple;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> fruit &#123;</span><br><span class="line">        Fruit::Apple =&gt; <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s an apple!&quot;</span>),</span><br><span class="line">        Fruit::Banana =&gt; <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s a banana!&quot;</span>),</span><br><span class="line">        Fruit::Orange =&gt; <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s an orange!&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h3><ol><li><p>切片（Slice）<br> 切片是对数组或字符串的引用，它允许我们引用集合中的一部分而不用拷贝整个集合。切片使用&amp;符号和范围表示。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">i32</span>] = &amp;numbers[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Slice: &#123;:?&#125;&quot;</span>, slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Option类型<br> Option类型在Rust中用于表示可能为空的值。它有两个可能的取值：Some(value)表示有值，None表示无值。Option类型可以帮助我们处理可能出现空值的情况。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y != <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x / y)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Result类型<br> Result类型在Rust中用于处理可能发生错误的操作。它有两个可能的取值：Ok(value)表示操作成功，返回一个值，Err(error)表示操作失败，返回一个错误。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y != <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x / y)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, error),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数签名和函数返回值"><a href="#函数签名和函数返回值" class="headerlink" title="函数签名和函数返回值"></a>函数签名和函数返回值</h4><p>如上面的笔记，函数关键字fn，返回值后面不带任务符号</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(a: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="comment">// a 是参数，要求是一个32位无符号整数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="number">0</span> <span class="comment">// 0是一个32位无符号整数，后面不加;，表示返回a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><h4 id="break返回值"><a href="#break返回值" class="headerlink" title="break返回值"></a>break返回值</h4><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><h2 id="rust特性"><a href="#rust特性" class="headerlink" title="rust特性"></a>rust特性</h2><h3 id="默认不可变性"><a href="#默认不可变性" class="headerlink" title="默认不可变性"></a>默认不可变性</h3><p>rust所有的变量都默认不可变，在声明时添加mut可改变其不可变性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line">a = <span class="number">13</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="number">11</span>;</span><br><span class="line">b = <span class="number">45</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>有个例外，rust支持const关键字，这就是一个常量，建议声明的常量名字全大写，由const声明的常量不支持mut</p><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>rust要求每一个值都有且只能有一个变量，从根源上避免了<a href="#####数据竞争">数据竞争</a>。</p><p>rust的所有权机制导致一旦一个变量被传递到了另一个作用范围，主要是从函数外部传递到内部，会导致外部的这个变量无效，在退出函数后，这个变量也不会重新有效（在函数内部被丢弃）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len); <span class="comment">// 这里，s1已经无效了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust支持传引用&amp;到函数，引用&amp;不会导致变量的所有权被转移，只是将值传递进函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123; <span class="comment">// 传进来一个可变的引用，支持修改外部的变量</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(s: &amp; <span class="type">String</span>) &#123; <span class="comment">// 不可变引用，不支持修改外部变量，只能使用这个值</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);  <span class="comment">// 不能通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust支持在函数内部声明一个变量，将其返回，外部就能够获得这个变量的所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust不支持返回在函数内部声明的变量的引用，因为引用只是值，变量本身会随着函数的退出而被丢弃，返回的引用就变成了无效的指针（dangling pointer）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s  <span class="comment">// 导致dangling pointer，无法通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，rust使用了严格的机制避免<a href="#####数据竞争">数据竞争</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题，可变引用会导致r1、r2的值不可靠</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="补充概念"><a href="#补充概念" class="headerlink" title="补充概念"></a>补充概念</h4><h5 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h5><ol><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;与其他后端语言的共性&quot;&gt;&lt;a href=&quot;#与其他后端语言的共性&quot; class=&quot;headerlink&quot; title=&quot;与其他后端语言的共性&quot;&gt;&lt;/a&gt;与其他后端语言的共性&lt;/h2&gt;&lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Rust" scheme="https://github.com/xyiling/xyiling.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://github.com/xyiling/xyiling.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>IEEE754数据转换示例</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/03/11/ieee754%E8%BD%AC%E6%8D%A2%E7%A4%BA%E4%BE%8B/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/03/11/ieee754%E8%BD%AC%E6%8D%A2%E7%A4%BA%E4%BE%8B/</id>
    <published>2024-03-10T16:00:00.000Z</published>
    <updated>2024-08-05T03:23:35.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IEEE754浮点数表示法"><a href="#IEEE754浮点数表示法" class="headerlink" title="IEEE754浮点数表示法"></a>IEEE754浮点数表示法</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">| sign | exp | tail |</span><br><span class="line">+-------------------+</span><br><span class="line"></span><br><span class="line">sign: 符号位 0正数 1负数，单精度和双精度下均只有 1 bit</span><br><span class="line">exp: 指数，单精度下指数有 8 bits，双精度下有 11 bits</span><br><span class="line">tail: 尾数，单精度下有 23 bits，双精度下有 52 bits</span><br></pre></td></tr></table></figure><h2 id="浮点数转二进制"><a href="#浮点数转二进制" class="headerlink" title="浮点数转二进制"></a>浮点数转二进制</h2><p>示例数据：5.75</p><p>step 1: 转换成二进制 101.11;</p><p>step 2: 将整数部分左右移，知道小数点前只有 1 个 1。 1.0111 右移 <strong>2</strong> 位，得到位数 0111;</p><p>step 3: 将这个移动的位数加上偏置值，单精度下，该偏置=127，双精度下，该偏置量=1023。指数exp = 2 + 127 = 129，得出指数二进制表示：1000 0001;</p><p>step 4: 将符号位、指数、位数整合起来，尾数不足 23bits 后面添0 得到该浮点数的二进制表示：<br>    <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------+-----------+------------------------------+</span><br><span class="line">| sign |    exp    |             tail             |</span><br><span class="line">+------+-----------+------------------------------+</span><br><span class="line">|   0  |  10000001 | 011 1000 0000 0000 0000 0000 |</span><br><span class="line">+------+-----------+------------------------------+</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IEEE754浮点数表示法&quot;&gt;&lt;a href=&quot;#IEEE754浮点数表示法&quot; class=&quot;headerlink&quot; title=&quot;IEEE754浮点数表示法&quot;&gt;&lt;/a&gt;IEEE754浮点数表示法&lt;/h2&gt;&lt;figure class=&quot;highlight txt&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计网osi/ios七层模型设备和协议</title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/03/11/%E8%AE%A1%E7%BD%91%E8%AE%BE%E5%A4%87%E5%8D%8F%E8%AE%AE/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/03/11/%E8%AE%A1%E7%BD%91%E8%AE%BE%E5%A4%87%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-03-10T16:00:00.000Z</published>
    <updated>2024-03-13T03:51:15.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网osi-ios七层模型设备和协议"><a href="#计网osi-ios七层模型设备和协议" class="headerlink" title="计网osi&#x2F;ios七层模型设备和协议"></a>计网osi&#x2F;ios七层模型设备和协议</h1><ol><li>集线器（Hub）</li></ol><ul><li>将所有的主机通过集线器连接在一起，主机发出的数据会通过集线器发送到所有主机，接收到数据的主机根据实际情况选择接受或拒绝数据。</li><li>特点：将数据广播到连接在集线器的所有主机，不分割广播域&#x2F;网络</li><li>工作层次：物理层</li></ul><ol start="2"><li>交换机（Switch）</li></ol><ul><li>交换机维护一张mac地址表，字节流数据发送到交换机后，交换机会解析出源mac地址和目标mac地址，如果源mac地址不存在于维护的mac地址表，交换机会将源mac地址和对应的端口绑定起来，下次如果有数据要发送到记录在表的主机，会根据mac地址表解析出对应的端口，然后将字节流直接发到目标主机。</li><li>特点：将数据发送到指定端口，会分割广播域，不分割网络</li><li>工作层次：数据链路层</li></ul><p>功能上的差异：交换机工作在数据链路层，能够识别数据包中的MAC地址信息。它根据MAC地址将数据准确地传输给目标端口，从而减少了不必要的数据传输，提高了网络的效率和安全性。<br>工作层次：OSI模型的第2层（数据链路层）。</p><ol start="3"><li>路由器（Router）</li></ol><p>功能上的差异：路由器工作在网络层，主要负责不同网络之间的数据传输和路由选择。它根据IP地址和路由协议，确定数据包的最佳路径，并能够处理不同网络协议的数据包，如IP、IPX等。<br>工作层次：OSI模型的第3层（网络层）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计网osi-ios七层模型设备和协议&quot;&gt;&lt;a href=&quot;#计网osi-ios七层模型设备和协议&quot; class=&quot;headerlink&quot; title=&quot;计网osi&amp;#x2F;ios七层模型设备和协议&quot;&gt;&lt;/a&gt;计网osi&amp;#x2F;ios七层模型设备和协议&lt;/h1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/03/03/custom/config/index/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/03/03/custom/config/index/</id>
    <published>2024-03-03T10:50:08.785Z</published>
    <updated>2024-03-03T10:53:39.138Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://github.com/xyiling/xyiling.github.io/2024/03/03/custom/css/custom/"/>
    <id>https://github.com/xyiling/xyiling.github.io/2024/03/03/custom/css/custom/</id>
    <published>2024-03-03T10:30:13.597Z</published>
    <updated>2024-03-03T10:47:08.842Z</updated>
    
    <content type="html"><![CDATA[body {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur),        default;}a,img {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur),        default;}/* 页脚footer *//* 渐变色滚动动画 */@-webkit-keyframes Gradient {    0% {        background-position: 0 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0 50%;    }}@keyframes Gradient {    0% {        background-position: 0 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0 50%;    }}#footer {    background: linear-gradient(-45deg, #ee7752, #ce3e75, #23a6d5, #23d5ab);    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite;    -o-user-select: none;    -ms-user-select: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    border-top-left-radius: 10px;    border-top-right-radius: 10px;}#footer:before {    background-color: rgba(0, 0, 0, 0);}/* 滚动条 */::-webkit-scrollbar {    width: 8px;    height: 8px;}::-webkit-scrollbar-track {    background-color: rgba(73, 177, 245, 0.2);    border-radius: 2em;}::-webkit-scrollbar-thumb {    background-color: #49b1f5;    background-image: -webkit-linear-gradient(45deg,            rgba(255, 255, 255, 0.4) 25%,            transparent 25%,            transparent 50%,            rgba(255, 255, 255, 0.4) 50%,            rgba(255, 255, 255, 0.4) 75%,            transparent 75%,            transparent);    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #49b1f5;}/* 分类卡片 */#aside_content.card-archivesul.card-archive-list> .card-archive-list-itemaspan:first-child,#aside_content.card-categoriesul.card-category-list> .card-category-list-itemaspan:first-child {    width: auto;    min-width: 50%;}#aside_content .card-widget,#recent-posts>.recent-post-item,.layout_page>div:first-child:not(.recent-posts),.layout_post>#page,.layout_post>#post,.read-mode .layout_post>#post {    background: var(--light_bg_color)}[data-theme=dark] #nav,[data-theme=dark] .layout_page>div:first-child:not(.recent-posts),[data-theme=dark] .layout_post>#post {    background-color: var(--dark_bg_color)}]]></content>
    
    
      
      
    <summary type="html">body {
    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur),
        default;
}

a,
img {
    cur</summary>
      
    
    
    
    
  </entry>
  
</feed>
