<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>xyl的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="cxx、Java、python、rust、r、汇编、计组、计网、os、数据结构、算法、web，都搞，论文也读，网课也看，笔记也会记在这，还会收集各种资源。">
<meta property="og:type" content="website">
<meta property="og:title" content="xyl的个人博客">
<meta property="og:url" content="https://github.com/xyiling/xyiling.github.io/page/3/index.html">
<meta property="og:site_name" content="xyl的个人博客">
<meta property="og:description" content="cxx、Java、python、rust、r、汇编、计组、计网、os、数据结构、算法、web，都搞，论文也读，网课也看，笔记也会记在这，还会收集各种资源。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xiaoyiling">
<meta property="article:tag" content="进步, 执念, 编程开发, 计算机科学, 计算机图形学, ai, 深度学习, 发疯">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xyl的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xyl的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">基本工资高才是福利，谈绩效的一律视为CPU</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/xyiling/xyiling.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-java总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/25/java%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2024-01-24T16:00:00.000Z" itemprop="datePublished">2024-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/25/java%E6%80%BB%E7%BB%93/">java开发笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>list自带排序：<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MyObject&gt; list = ...;</span><br><span class="line">list.sort((o1, o2) -&gt; o2.getXXX().compareTo(o1.getXXX()));   <span class="comment">// 倒序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x.compareTo(y):</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * 1. &gt; 0, x &gt; y; </span></span><br><span class="line"><span class="comment"> * 2. &lt; 0, x &lt; y;</span></span><br><span class="line"><span class="comment"> * 3. = 0, x = y</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure><br>特点：</p>
<ul>
<li>自排序，无返回值</li>
<li>如果是对象类型的元素，需要重写Comporator比较器</li>
</ul>
<h2 id="分割字符串，构造不大于指定大小的字串"><a href="#分割字符串，构造不大于指定大小的字串" class="headerlink" title="分割字符串，构造不大于指定大小的字串"></a>分割字符串，构造不大于指定大小的字串</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">splitStr</span><span class="params">(String input, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    List&lt;String&gt; resultStrList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    String[] lines = input.split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sb.length() + line.length() + <span class="number">1</span> &gt; length) &#123; <span class="comment">// 超过目标长度</span></span><br><span class="line">            resultStrList.add(sb.toString()); <span class="comment">// 添加当前字串到结果列表</span></span><br><span class="line">            sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 重置 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(line).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加最后一个字串</span></span><br><span class="line">    <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultStrList.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStrList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2024/01/25/java%E6%80%BB%E7%BB%93/" data-id="cm1em9i5z000c2jwp6zv85pts" data-title="java开发笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-csapp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/28/csapp/" class="article-date">
  <time class="dt-published" datetime="2023-12-27T16:00:00.000Z" itemprop="datePublished">2023-12-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/28/csapp/">csapp阅读笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ch1-计算机系统漫游"><a href="#ch1-计算机系统漫游" class="headerlink" title="ch1 计算机系统漫游"></a>ch1 计算机系统漫游</h2><ol>
<li>程序在计算机中以‘比特’的形式存储；</li>
<li>c程序到可执行程序：.c(源文件) —&gt; .i(预编译后得到的文件) —&gt; .s(编译后得到的文件) —&gt; .o(汇编后得到的文件) —&gt; .out(可执行文件)</li>
<li>了解编译系统如何工作有什么好处？<ul>
<li>优化程序性能：switch和if-else如何取舍？while与for如何选择？指针与索引访问数组，哪一个效率更高？</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2023/12/28/csapp/" data-id="cm1em9i5t00052jwp4v1wehoa" data-title="csapp阅读笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-intel x86汇编语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/27/intel%20x86%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-12-26T16:00:00.000Z" itemprop="datePublished">2023-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/27/intel%20x86%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95/">intel x86汇编语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-保护模式和实模式"><a href="#1-1-保护模式和实模式" class="headerlink" title="1.1 保护模式和实模式"></a>1.1 保护模式和实模式</h3><h3 id="1-2-段"><a href="#1-2-段" class="headerlink" title="1.2 段"></a>1.2 段</h3><h4 id="1-2-1-段的概念"><a href="#1-2-1-段的概念" class="headerlink" title="1.2.1 段的概念"></a>1.2.1 段的概念</h4><h4 id="1-2-2-为什么分段"><a href="#1-2-2-为什么分段" class="headerlink" title="1.2.2 为什么分段"></a>1.2.2 为什么分段</h4><h4 id="1-2-3-使用intel汇编语法访问内存段"><a href="#1-2-3-使用intel汇编语法访问内存段" class="headerlink" title="1.2.3 使用intel汇编语法访问内存段"></a>1.2.3 使用intel汇编语法访问内存段</h4><h3 id="1-3-偏移"><a href="#1-3-偏移" class="headerlink" title="1.3 偏移"></a>1.3 偏移</h3><h4 id="1-3-1-偏移的概念"><a href="#1-3-1-偏移的概念" class="headerlink" title="1.3.1 偏移的概念"></a>1.3.1 偏移的概念</h4><h4 id="1-3-1-段内寻址"><a href="#1-3-1-段内寻址" class="headerlink" title="1.3.1 段内寻址"></a>1.3.1 段内寻址</h4><h3 id="1-4-中断"><a href="#1-4-中断" class="headerlink" title="1.4 中断"></a>1.4 中断</h3><h4 id="1-4-1-中断的概念"><a href="#1-4-1-中断的概念" class="headerlink" title="1.4.1 中断的概念"></a>1.4.1 中断的概念</h4><h4 id="1-4-2-什么时候触发中断"><a href="#1-4-2-什么时候触发中断" class="headerlink" title="1.4.2 什么时候触发中断"></a>1.4.2 什么时候触发中断</h4><h4 id="1-4-3-中断指令"><a href="#1-4-3-中断指令" class="headerlink" title="1.4.3 中断指令"></a>1.4.3 中断指令</h4><h3 id="1-5-寄存器寻址"><a href="#1-5-寄存器寻址" class="headerlink" title="1.5 寄存器寻址"></a>1.5 寄存器寻址</h3><h3 id="1-6-内存寻址"><a href="#1-6-内存寻址" class="headerlink" title="1.6 内存寻址"></a>1.6 内存寻址</h3><h3 id="1-7-io"><a href="#1-7-io" class="headerlink" title="1.7 io"></a>1.7 io</h3><h2 id="二、基本语法和代码落地"><a href="#二、基本语法和代码落地" class="headerlink" title="二、基本语法和代码落地"></a>二、基本语法和代码落地</h2><h2 id="三、对比at-amp-t汇编语法"><a href="#三、对比at-amp-t汇编语法" class="headerlink" title="三、对比at&amp;t汇编语法"></a>三、对比at&amp;t汇编语法</h2><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2023/12/27/intel%20x86%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95/" data-id="cm1em9i5x000a2jwpdt0ahljr" data-title="intel x86汇编语法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-http协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/22/http%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2023-12-21T16:00:00.000Z" itemprop="datePublished">2023-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/22/http%E5%8D%8F%E8%AE%AE/">http协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、概念特点"><a href="#一、概念特点" class="headerlink" title="一、概念特点"></a>一、概念特点</h2><p>无状态协议，上一条http请求与下一条http请求没有任何联系，如果上一条是登录请求，下一条如果没有附带上一条的结果（也就是状态），下一条依旧是未登录状态，由此产生cookie技术</p>
<h2 id="二、表现"><a href="#二、表现" class="headerlink" title="二、表现"></a>二、表现</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://主机地址[:端口][绝对路径]</span><br></pre></td></tr></table></figure>
<h2 id="三、基本结构"><a href="#三、基本结构" class="headerlink" title="三、基本结构"></a>三、基本结构</h2><h3 id="3-1-请求"><a href="#3-1-请求" class="headerlink" title="3.1 请求"></a>3.1 请求</h3><blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------------------------+</span><br><span class="line">|      method       |    uri    |    version    |    CRLF    |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                           header                           |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                                                            |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                            data                            |</span><br><span class="line">+------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
</blockquote>
<p>method:</p>
<ul>
<li>GET请求获取URI所标识的资源</li>
<li>POST在URI所标识的资源后增加新的数据</li>
<li>HEAD请求获取由URI所标识的资源的响应消息报头</li>
<li>PUT请求服务器存储或修改一个资源，并用URI作为其标识</li>
<li>DELETE请求服务器删除URI所标识的资源</li>
<li>TRACE请求服务器回送收到的请求信息，主要用于测试或诊断</li>
<li>CONNECT保留将来使用</li>
<li>OPTIONS请求查询服务器的性能，或者查询与资源相关的选项和需求</li>
</ul>
<blockquote>
<p>HTTP请求头<br>消息报头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息<br>HTTP请求正文<br>只有在发送POST请求时才会有请求正文，GET方法并没有请求正文。</p>
</blockquote>
<h3 id="3-2-响应"><a href="#3-2-响应" class="headerlink" title="3.2 响应"></a>3.2 响应</h3><blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------------------------+</span><br><span class="line">|      version      |    code    |     text     |    CRLF    |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                           header                           |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                                                            |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                            data                            |</span><br><span class="line">+------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、端口约定"><a href="#四、端口约定" class="headerlink" title="四、端口约定"></a>四、端口约定</h2><p>应用层协议通常都制定好了端口号，如http协议指定80端口，https默认端口443，telnet默认端口23，dns默认端口53，snmp默认161。</p>
<p>传输层协议，如tcp、udp，都是需要端口，但是可以随意指定，比如搭建一个tcp服务器，应用层使用telnet接收消息，对应的tcp端口就可以设置为23，再启动一个http服务器，对应另一个tcp服务器端口可以设置为80等</p>
<h2 id="五、http-https在应用层的作用"><a href="#五、http-https在应用层的作用" class="headerlink" title="五、http/https在应用层的作用"></a>五、http/https在应用层的作用</h2><p>负责发起网页请求，将用户需要的信息返回回来</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2023/12/22/http%E5%8D%8F%E8%AE%AE/" data-id="cm1em9i5v00082jwp6tao23lg" data-title="http协议" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-网络层ip协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/22/%E7%BD%91%E7%BB%9C%E5%B1%82ip%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2023-12-21T16:00:00.000Z" itemprop="datePublished">2023-12-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/22/%E7%BD%91%E7%BB%9C%E5%B1%82ip%E5%8D%8F%E8%AE%AE/">网络层ip协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="IP协议结构"><a href="#IP协议结构" class="headerlink" title="IP协议结构"></a>IP协议结构</h2><p><img src="/img/loading.gif" data-original="sfzoz81v.bmp" alt="ip协议结构图"><br>字段详细说明</p>
<pre><code>1. Version（版本号）：IP 协议版本号。目前只有两个版本：IPv4 和 IPv6
2. HeaderLength（IP 协议头部长度）：IP 协议头部的长度，单位字节（32bit）需要这个值是因为任选字段的长度是可变的，这个字段占 4bit（最多能表示 15 个 32bit 的的字，即 4*15=60 个字节的首部长度），因此 IP 头部最多有 60 字节长度。正常的长度是 20 字节；如果有额外的 IP 的 options 选项，还得加上 option 的长度。
   1. TypeofService (服务类型)：标示包传输优先级。总共 8 位，是由 3 个优先权位（不再使用），4 个 TOS 位，1 个固定的 0 组成。
    4 个 TOS 位：最新延迟、最大吞吐量、最高可靠性、最小成本，只能 4 选一。
3. TotalLength（包长度）：整个 IP 包的长度，16 位，最大可以标示 65536 个字节，TotalLength-HeaderLength = 数据长度。通过 HeaderLength 和 TotalLength 就可以知道数据的起始位置和结束位置。
4. Identifier（标识符）：网络中转发的 IP 报文的长度可以不同，但如果报文长度超过了数据链路所支持的最大长度，则报文就需要分割成若干个小的片段才能在链路上传输。比如以太网帧中数据最大长度（MTU）为 1500 字节，大于 MTU 的都会被分割，被分割的每个包都有相同的一个值，表示这是同一个 ip 包。
5. Flag（标志位）：标志字段在 IP 报头中占 3 位。
   - 第 1 位作为保留；
   - 第 2 位，分段，是否允许分片；（如果不允许分片，包超过了数据连路支持的最大长度，则丢弃该包，返回发送者一个 ICMP 错误）
   - 第 3 位，更多分段。表示是否最后一个分片。
</code></pre><p>当目的主机接收到一个 IP 数据报时，会首先查看该数据报的标识符，并且检查标志位的第 3 位是置 0 或置 1，以确定是否还有更多的分段。如果还有后续报文，接收主机则将接收到的报文放在缓存直到接收完所有具有相同标识符的数据报，然后再进行重组。</p>
<pre><code>1. FragmentedOffset（偏移量）：当某个 IP 大包分成多片时，各个分片是不按顺序达到目的地的，IP 包根据分片的偏移量进行重组包。（跟 TCP 原理一样）
2. （TimetoLive）生存时间：表示数据包经过的路由器个数。如果网络上有些路由器的路由表配置不合理，路由寻址可能会导致死循环，数据包会一直循环传输。IP 包发送的时候可以设置一个 TTL 值，比如 TTL=64，没经过一个路由器 TTL 减 1，减到 0 还没到到目的地，路由器会抛弃这个 IP 包，并使用一个 ICMP 消息通知发送方。
3. Protocal（协议）：协议类型 1：ICMP，2：IGMP，6：TCP，17：UDP。
4.  HeaderCheckSum（首部校验和）：校验 IP 协议头，判断 IP 协议头是否正确传输。
5.  SourceAddress（源 IP）：请求方 IP
6.  DistinationAddress（目的 IP）：响应方 IP
7.  Options（可选字段）：IP 支持很多可选选项
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2023/12/22/%E7%BD%91%E7%BB%9C%E5%B1%82ip%E5%8D%8F%E8%AE%AE/" data-id="cm1em9i6n00192jwpd8xu9yk7" data-title="网络层ip协议" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IP-%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84-%E7%BD%91%E7%BB%9C%E5%B1%82/" rel="tag">IP, 头部结构, 网络层</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据包在七层模型的传输细节" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/21/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A0%E8%BE%93%E7%BB%86%E8%8A%82/" class="article-date">
  <time class="dt-published" datetime="2023-12-20T16:00:00.000Z" itemprop="datePublished">2023-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/21/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A0%E8%BE%93%E7%BB%86%E8%8A%82/">数据包在七层模型的传输细节</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据包在七层模型的传输细节"><a href="#数据包在七层模型的传输细节" class="headerlink" title="数据包在七层模型的传输细节"></a>数据包在七层模型的传输细节</h1><h2 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h2><p>数据自应用层产生，在应用层经过</p>
<h3 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h3><ul>
<li>按传输范围分：广域网wan、城域网can、<strong>局域网lan</strong>、个人区域网an</li>
<li>按网络拓补结构分：总线型网络、环状网络、星型网络<h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h2>向app提供网络接口，直接向用户提供服务<h3 id="2-1-应用层工作内容"><a href="#2-1-应用层工作内容" class="headerlink" title="2.1 应用层工作内容"></a>2.1 应用层工作内容</h3><h3 id="2-2-应用层协议"><a href="#2-2-应用层协议" class="headerlink" title="2.2 应用层协议"></a>2.2 应用层协议</h3></li>
<li>远程登录：telnet、ssh</li>
<li>文件传输: ftp、tftp、sftp</li>
<li>电子邮件：smtp、pop3、imap</li>
<li>网页浏览：http、https</li>
<li>网络管理：dns、dhcp<h3 id="2-3-应用层如何提供功能服务："><a href="#2-3-应用层如何提供功能服务：" class="headerlink" title="2.3 应用层如何提供功能服务："></a>2.3 应用层如何提供功能服务：</h3></li>
<li><a href="http协议">http/https的概念和作用</a><h2 id="三、表示层"><a href="#三、表示层" class="headerlink" title="三、表示层"></a>三、表示层</h2><h3 id="3-1-表示层的工作内容"><a href="#3-1-表示层的工作内容" class="headerlink" title="3.1 表示层的工作内容"></a>3.1 表示层的工作内容</h3></li>
</ul>
<h3 id="3-2-表示层如何处理数据包"><a href="#3-2-表示层如何处理数据包" class="headerlink" title="3.2 表示层如何处理数据包"></a>3.2 表示层如何处理数据包</h3><h2 id="四、会话层"><a href="#四、会话层" class="headerlink" title="四、会话层"></a>四、会话层</h2><h3 id="4-1-会话层工作内容"><a href="#4-1-会话层工作内容" class="headerlink" title="4.1 会话层工作内容"></a>4.1 会话层工作内容</h3><h3 id="4-2-会话层如何处理数据包"><a href="#4-2-会话层如何处理数据包" class="headerlink" title="4.2 会话层如何处理数据包"></a>4.2 会话层如何处理数据包</h3><h2 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h2><h3 id="5-1-传输层工作内容"><a href="#5-1-传输层工作内容" class="headerlink" title="5.1 传输层工作内容"></a>5.1 传输层工作内容</h3><h3 id="5-2-传输层协议"><a href="#5-2-传输层协议" class="headerlink" title="5.2 传输层协议"></a>5.2 传输层协议</h3><h3 id="5-3-传输层如何处理数据包"><a href="#5-3-传输层如何处理数据包" class="headerlink" title="5.3 传输层如何处理数据包"></a>5.3 传输层如何处理数据包</h3><h2 id="六、网络层"><a href="#六、网络层" class="headerlink" title="六、网络层"></a>六、网络层</h2><h3 id="6-1-网络层工作内容"><a href="#6-1-网络层工作内容" class="headerlink" title="6.1 网络层工作内容"></a>6.1 网络层工作内容</h3><h3 id="6-2-网络层协议"><a href="#6-2-网络层协议" class="headerlink" title="6.2 网络层协议"></a>6.2 网络层协议</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><h4 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h4><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><h4 id="RARP协议"><a href="#RARP协议" class="headerlink" title="RARP协议"></a>RARP协议</h4><h3 id="6-3-网络层如何处理数据包"><a href="#6-3-网络层如何处理数据包" class="headerlink" title="6.3 网络层如何处理数据包"></a>6.3 网络层如何处理数据包</h3><h2 id="七、数据链路层"><a href="#七、数据链路层" class="headerlink" title="七、数据链路层"></a>七、数据链路层</h2><h3 id="7-1-数据链路层工作内容"><a href="#7-1-数据链路层工作内容" class="headerlink" title="7.1 数据链路层工作内容"></a>7.1 数据链路层工作内容</h3><h4 id="成帧"><a href="#成帧" class="headerlink" title="成帧"></a>成帧</h4><h4 id="帧纠错"><a href="#帧纠错" class="headerlink" title="帧纠错"></a>帧纠错</h4><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h3 id="7-2-数据链路层协议"><a href="#7-2-数据链路层协议" class="headerlink" title="7.2 数据链路层协议"></a>7.2 数据链路层协议</h3><h3 id="7-3-数据链路层如何处理数据包"><a href="#7-3-数据链路层如何处理数据包" class="headerlink" title="7.3 数据链路层如何处理数据包"></a>7.3 数据链路层如何处理数据包</h3><h2 id="八、物理层"><a href="#八、物理层" class="headerlink" title="八、物理层"></a>八、物理层</h2><h3 id="8-1-物理层工作内容"><a href="#8-1-物理层工作内容" class="headerlink" title="8.1 物理层工作内容"></a>8.1 物理层工作内容</h3><p>物理层主要对数据链路层传下来的比特流进行透明传输，根据传输方式的不同，可以将物理层的传输概念分类</p>
<ul>
<li>按数据类型分：<a href="#信号转换">模拟信号和数字信号</a></li>
<li>按是否支持同时发送消息分：<a href="#单工、半双工、双工">单工、半双工、双工</a></li>
<li>按传输方式分：<a href="#并行串行传输">并行、串行</a></li>
<li>按编码方式分：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ColaHua/p/12490529.html">归零编码、非归零编码、曼彻斯特编码、差分曼彻斯特编码</a><br><img src="/img/loading.gif" data-original="20200314085655.png" alt="物理层编码方式"></li>
</ul>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><h4 id="信号转换"><a href="#信号转换" class="headerlink" title="信号转换"></a>信号转换</h4><p>在物理层的传输介质中传输的信号共分为两种，模拟信号、数字信号，电话、有线电视属于模拟信号，电脑上网就用的是数字信号。</p>
<blockquote>
<p>modem（猫：调制解调器），最早的家用网络是通过电话线进行上网的（即模拟信号），需要使用modem将数字信号和模拟信号进行相互转换</p>
<ul>
<li>调制：将数字信号转换为模拟信号</li>
<li>解调：将模拟信号转换为数字信号<h4 id="并行-串行传输"><a href="#并行-串行传输" class="headerlink" title="并行/串行传输"></a>并行/串行传输</h4></li>
<li>串行通信：将一个字符的二进制代码按从低位到高位顺序传输，传输中需要建立一个信道。</li>
<li>并行通信：将一个字符的二进制代码同时通过8条信道同时传输，每发送一个字符都需要建立8条信道，成本较高。<h4 id="单工、半双工、双工"><a href="#单工、半双工、双工" class="headerlink" title="单工、半双工、双工"></a>单工、半双工、双工</h4></li>
<li>单工通信：只能向一个方向发送信息，例如广播、电台、寻呼机</li>
<li>半双工通信：同一时刻只能有一个方向发送信息，例如对讲机</li>
<li>全双工通信：可以同时发送信息和接收信息，例如手机、电话<h3 id="8-2-物理层协议"><a href="#8-2-物理层协议" class="headerlink" title="8.2 物理层协议"></a>8.2 物理层协议</h3></li>
<li>点对点通信线路物理层协议</li>
<li>广播通信线路物理层协议<ul>
<li>有线通信线路（网线形式的网络）</li>
<li>无线通信线路（WIFI）<h3 id="8-3-物理层如何处理数据包"><a href="#8-3-物理层如何处理数据包" class="headerlink" title="8.3 物理层如何处理数据包"></a>8.3 物理层如何处理数据包</h3></li>
</ul>
</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2023/12/21/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A0%E8%BE%93%E7%BB%86%E8%8A%82/" data-id="cm1em9i6j000w2jwpfio62ms3" data-title="数据包在七层模型的传输细节" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux内核启动流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/19/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-12-18T16:00:00.000Z" itemprop="datePublished">2023-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/19/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">linux内核启动流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、硬件自检"><a href="#一、硬件自检" class="headerlink" title="一、硬件自检"></a>一、硬件自检</h2><ol>
<li><p>电源自检<br> 按下开关键后，电源启动，计算机会进行电源自检POST，主要是检查<strong>电源是否连接正常</strong>、<strong>电源开关是否正常</strong>、<strong>电源输出是否稳定</strong>，防止损坏计算机的硬件设备。<br> CPU状态：实模式，CS=0xFFFF;IP=0x0000，对应实际物理地址0xFFFF0(CS左移4位+IP)，指向装有BIOS的ROM</p>
</li>
<li><p>BIOS自检<br> 电源自检通过，主板通电，读取ROM存放的BIOS程序，进行BIOS自检。BIOS负责管理和控制计算机硬件设备，本质上是一组”程序代码”。</p>
<p> BIOS作为CPU要进行处理的第一个“可执行程序”，也就是第一个“开机启动项”。其程序代码事先被刷入集成在主板的ROM芯片中，主要保存着系统设置程序、基本输入输出程序、开机上电自检程序和系统启动自举程序等</p>
<blockquote>
<p>ROM: 只读存储器，不需要供电也可保持数据不丢失。这点特性和内存有着鲜明的对比<br>现在一般用Flash闪存来代替ROM，由于ROM写入后就不能修改，改用Flash闪存后，既方便又能用专用程序即可修改其中代码</p>
</blockquote>
<p> BIOS自检内容：</p>
<p> 硬件自检-&gt;初始化</p>
<p> 自检对象：处理器、内存、硬盘、显卡、声卡、键盘、鼠标、显示器等</p>
</li>
<li><p>选择引导设备、读取mbr并执行<br> 从第一设备中读取MBR，并且将程序放在0x7c00的内存地址</p>
<blockquote>
<p>磁盘：每个盘面划分成了一圈一圈的磁道，最外圈是0磁盘。然后每个磁盘又划分为了一个个小块，小块叫做扇区。扇区大小固定，是512个字节。<br>MBR在0盘0道0扇区上(最外层磁盘的最外围磁道的第一个扇区)，也就是该储存设备的第一个扇区(大小512个字节)。存放用于启动操作系统的引导程序代码，引导操作系统的启动</p>
</blockquote>
<p> mbr由三个部分组成：</p>
<ul>
<li>第一部分446个字节：主引导程序boot loader</li>
<li><p>第二部分64个字节：记录分区表<br>  硬盘可以分区，每个区可以安装不同的os，mbr必须知道将控制权转交给哪个操作系统。分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。<br>  每个主分区的16个字节，由6个部分组成：</p>
<ul>
<li>第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</li>
<li>第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</li>
<li>第5个字节：主分区类型。</li>
<li>第6-8个字节：主分区最后一个扇区的物理位置。</li>
<li>第9-12字节：该主分区第一个扇区的逻辑地址。</li>
<li><p>第13-16字节：主分区的扇区总数，决定了这个主分区的长度，一个主分区的扇区总数最多不超过2的32次方。</p>
<p>当主引导程序将硬盘的第一个扇区中读取到的操作系统引导程序代码(512 个字节的内容)，加载(原封不动地复制)到计算机内存0x7c00这个位置。这个过程需要依靠硬盘控制器和指令集来完成。</p>
</li>
</ul>
</li>
<li>第三个部分占2个字节：主引导记录的签名（0x55和0xAA）,如果这512字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。如果到最后还是没找到符合条件的，直接报出一个无启动区的error。</li>
</ul>
</li>
<li><p>0x7c00是什么地址？<br> 0x7C00这个地址，第一次出现于IBM PC 5150电脑，IBM PC 5150是x86（32位）IBM PC/AT系列的老祖宗，使用了intel 8088芯片，后人一直沿用这个地址以保持兼容。<br> IBM PC 5150电脑的操作系统是86-DOS，它最少需要32KB的内存，32KB=32 * 1024B = 32768B = 0x8000B, 由于内存地址是从0x0000开始的，32位末地址是0x8000 -1=0x7FFF所以32KB的内存地址是0x0000～0x7FFF<br> 现在又知主引导记录需要512字节，其本身引导程序的堆栈/数据区域也至少需要512 字节</p>
<p> 0x7FFF -512 -512 + 1=0x7C00，这样就得出0x7C00这个地址了。</p>
<p> 计算机启动会后，内存布局如下：</p>
 <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+——————— 0×0</span><br><span class="line">| Interrupts vectors（中断向量表）</span><br><span class="line">+——————— 0×400</span><br><span class="line">| BIOS data area（BIOS的数据区域）</span><br><span class="line">+——————— 0×5??</span><br><span class="line">| OS load area（操作系统加载区域）</span><br><span class="line">+——————— 0x7C00</span><br><span class="line">| Boot sector（引导区域）</span><br><span class="line">+——————— 0x7E00</span><br><span class="line">| Boot data/stack（引导数据/堆栈）</span><br><span class="line">+——————— 0x7FFF</span><br><span class="line">| (not used) </span><br><span class="line">+——————— (…)</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动操作系统<br> 跳转到c程序或是汇编程序，这时候就是操作系统的代码范畴了</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2023/12/19/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" data-id="cm1em9i65000e2jwphjfy0dq3" data-title="linux内核启动流程" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux-kernel-boot/" rel="tag">linux, kernel, boot</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-消息队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2023-12-18T16:00:00.000Z" itemprop="datePublished">2023-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列思想和实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><ul>
<li>producer：消息生产者，多个，负责将消息发送到消息队列</li>
<li>broker：消息处理中心，包含多个消息队列，负责存储消息、确认、重试等</li>
<li>consumer：消息消费者，从消息队列获取消息<h2 id="二、消息队列模式"><a href="#二、消息队列模式" class="headerlink" title="二、消息队列模式"></a>二、消息队列模式</h2></li>
<li>点对点模式</li>
</ul>
<p>多个producer向同一个broker的同一个queue发送消息，一个具体的消息只能由一个consumer消费</p>
<ul>
<li>发布/订阅模式</li>
</ul>
<p>单个消息可以被多个consumer消费</p>
<h2 id="三、RocketMQ简要概述"><a href="#三、RocketMQ简要概述" class="headerlink" title="三、RocketMQ简要概述"></a>三、RocketMQ简要概述</h2><p>RocketMQ 是阿里开源的消息中间件，纯Java开发，高性能、高可靠、高实时、适合大规模分布式系统应用。</p>
<p>RocketMQ 思路起源于 Kafka，对消息的可靠传输及事务性做了优化</p>
<h3 id="3-1-重要概念"><a href="#3-1-重要概念" class="headerlink" title="3.1 重要概念"></a>3.1 重要概念</h3><ul>
<li>Name 服务器（NameServer）：充当注册中心，类似 Kafka 的 Zookeeper。</li>
<li>Broker: 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。</li>
<li>主题（Topic）：消息的第一级类型，一条消息必须有一个 Topic。</li>
<li>子主题（Tag）：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。</li>
<li>分组（Group）：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。</li>
<li>队列（Queue）：可以类比 Kafka 的分区 Partition。<h3 id="3-2-工作原理"><a href="#3-2-工作原理" class="headerlink" title="3.2 工作原理"></a>3.2 工作原理</h3>RocketMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。</li>
</ul>
<p>为了提高并发能力，一个 Topic 包含多个 Queue，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。</p>
<p>RocketMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。</p>
<p>消费 Queue 的过程中，通过偏移量记录消费的位置。<br><img src="/img/loading.gif" data-original="640.png" alt="rocket消息偏移量"></p>
<h3 id="3-3-架构"><a href="#3-3-架构" class="headerlink" title="3.3 架构"></a>3.3 架构</h3><p>RocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。</p>
<p>Broker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。</p>
<p>如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。</p>
<p><img src="/img/loading.gif" data-original="640.jpg" alt="rocketmq的queue"></p>
<p>Broker 通过集群部署，并且提供了 master/slave 的结构，slave 定时从 master 同步数据（同步刷盘或者异步刷盘），如果 master 宕机，则 slave 提供消费服务，但是不能写入消息。</p>
<h2 id="四、部署和使用rocketMQ"><a href="#四、部署和使用rocketMQ" class="headerlink" title="四、部署和使用rocketMQ"></a>四、部署和使用rocketMQ</h2><h3 id="4-1-环境搭建"><a href="#4-1-环境搭建" class="headerlink" title="4.1 环境搭建"></a>4.1 环境搭建</h3><h3 id="4-2-java代码实现"><a href="#4-2-java代码实现" class="headerlink" title="4.2 java代码实现"></a>4.2 java代码实现</h3><h3 id="4-3-成果"><a href="#4-3-成果" class="headerlink" title="4.3 成果"></a>4.3 成果</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2023/12/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" data-id="cm1em9i6m00132jwpby04b845" data-title="消息队列思想和实现" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux进程间通信" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/12/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="article-date">
  <time class="dt-published" datetime="2023-12-11T16:00:00.000Z" itemprop="datePublished">2023-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/12/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">Linux进程间通信</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>不同进程的地址空间是隔离的。A 进程的地址 0x4000 和 B 进程的 0x4000 之间没有任何关系。如果要进行进程间通信，最常用的做法是让进程之间通过 127.0.0.1 或者是 Unix Domain Socket 等本机网络手段进行数据的传输。这个方案在传输的数据量较小的时候工作是很不错的。但如果进程间想共享的数据特别大，比如说几个 GB，那如果使用网络 IO 方案的话，就会涉及到大量的内存拷贝的开销，导致比较低的程序性能。这时可以采用进程间<strong><u><em>共享内存</em></u></strong>的方法来在通信时避免内存拷贝。</p>
<h2 id="一、共享内存的使用方式"><a href="#一、共享内存的使用方式" class="headerlink" title="一、共享内存的使用方式"></a>一、共享内存的使用方式</h2><p>共享内存发送方进程的开发基本过程是调用 memfd_create 创建一个内存文件。然后通过 mmap 系统调用为这个内存文件申请一块<strong>共享内存</strong>。然后这个内存文件就可以写入数据了。最后把这个文件的句柄通过 Unix Domain Socket 的方式给接收方进程发送过去。</p>
<p>下面是发送方的核心代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建内存文件</span></span><br><span class="line"> fd = memfd_create(<span class="string">&quot;Server memfd&quot;</span>, ...);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 为内存文件申请 MAP_SHARED 类型的内存</span></span><br><span class="line"> shm = mmap(<span class="literal">NULL</span>, shm_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 向共享内存中写入数据</span></span><br><span class="line"> <span class="built_in">sprintf</span>(shm, <span class="string">&quot;这段内容是保存在共享内存里的，接收方和发送方都能根据自己的fd访问到这块内容&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 把共享内存文件的句柄给接收方进程发送过去</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span>;</span></span><br><span class="line"> *((<span class="type">int</span> *) CMSG_DATA(CMSG_FIRSTHDR(&amp;msgh))) = fd;</span><br><span class="line"> sendmsg(conn, &amp;msgh, <span class="number">0</span>);</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共享内存接收方的工作过程是先用 Unix Domain Socket 连接上服务器，然后使用 recvmsg 就可以收到发送方发送过来的文件句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 Unix Domain Socket 连接发送方</span></span><br><span class="line">    connect(conn, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un));</span><br><span class="line">    <span class="comment">// 通过连接取出发送方发送过来的内存文件句柄</span></span><br><span class="line">    <span class="type">int</span> size = recvmsg(conn, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">    fd = *((<span class="type">int</span> *) CMSG_DATA(cmsgh));</span><br><span class="line">    <span class="comment">// 读取共享文件中的内容</span></span><br><span class="line">    shm = mmap(<span class="literal">NULL</span>, shm_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存中的文件内容是: %s\n&quot;</span>, shm);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样这两个进程都各自有一个文件句柄，在底层上是指向同一个内存文件的。这样就实现了发送方和接收方之间的内存文件共享了。</p>
<p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/BBjAFF4hcwpfibKtKUONu125vkLvMX4gxsghs13X2ueOHsvh0O0O3JSdby9EpDbK2giaA5IN0ib4D3AdXsjw8GTWA/640?wx_fmt=png&amp;from=appmsg" alt="img"></p>
<p>接下来深入地分析 memfd_create、 mmap、以及 Unix Domain socket sendmsg 和 recvmsg 的底层工作原理，来看看它们是如何配合来实现跨进程共享内存的。</p>
<h2 id="二、共享内存文件原理"><a href="#二、共享内存文件原理" class="headerlink" title="二、共享内存文件原理"></a>二、共享内存文件原理</h2><p>在发送方发送文件之前，需要先通过 memfd_create 来创建一个内存文件，然后再使用 mmap 为其分配内存。</p>
<h3 id="2-1-创建内存文件"><a href="#2-1-创建内存文件" class="headerlink" title="2.1 创建内存文件"></a>2.1 创建内存文件</h3><p>其中 memfd_create 函数是一个系统调用。内核中它的主要逻辑有两个，一是调用 get_unused_fd_flags 申请一个没使用过的文件句柄，二是调用 shmem_file_setup 创建一个共享内存文件。</p>
<p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/BBjAFF4hcwpfibKtKUONu125vkLvMX4gxS5xjbLGFZ5ZiaDmdF9iccFUwPKGc3RpdYOzRhALCcaORtS8zxflCyByw/640?wx_fmt=png&amp;from=appmsg" alt="img"></p>
<p> memfd_create 的源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:mm/memfd.c</span></span><br><span class="line">SYSCALL_DEFINE2(memfd_create,<span class="type">const</span> <span class="type">char</span> __user *, uname, <span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 申请一个未使用过的文件句柄</span></span><br><span class="line"> fd = get_unused_fd_flags((flags &amp; MFD_CLOEXEC) ? O_CLOEXEC : <span class="number">0</span>);</span><br><span class="line"> <span class="comment">// 创建一个共享内存的文件</span></span><br><span class="line"> file = shmem_file_setup(name, <span class="number">0</span>, VM_NORESERVE);</span><br><span class="line"></span><br><span class="line"> fd_install(fd, file);</span><br><span class="line"> <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中在 shmem_file_setup 函数中又调用了 __shmem_file_setup。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:mm/shmem.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">shmem_file_setup</span>(<span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, ...)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 申请一个 inode</span></span><br><span class="line"> inode = shmem_get_inode(mnt-&gt;mnt_sb, <span class="literal">NULL</span>, S_IFREG | S_IRWXUGO, <span class="number">0</span>, flags);</span><br><span class="line"> inode-&gt;i_flags |= i_flags;</span><br><span class="line"> inode-&gt;i_size = size;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 创建一个文件</span></span><br><span class="line"> res = alloc_file_pseudo(inode, mnt, name, O_RDWR,</span><br><span class="line">    &amp;shmem_file_operations);</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>磁盘文件在内核的实现中是由 inode 和 struct file 对象一起组成的。共享内存文件也一样，__shmem_file_setup 中就是先申请了一个 inode，然后再调用 alloc_file_pseudo 创建一个文件。值得注意的是，这个文件并非是磁盘上的文件，而只是在内存里的。</p>
<h3 id="2-2-mmap申请内存"><a href="#2-2-mmap申请内存" class="headerlink" title="2.2 mmap申请内存"></a>2.2 mmap申请内存</h3><p><code>mmap</code>也是一个系统调用，开篇处调用它的时候传入的第三个<code>flag</code>参数是<code>MAP_SHARED</code>。这表示的是要通过<code>mmap</code>申请一块跨进程可共享的内存出来。<code>mmap</code>的实现入口在 arch/x86/kernel/sys_x86_64.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:arch/x86/kernel/sys_x86_64.c</span></span><br><span class="line">SYSCALL_DEFINE6(mmap, <span class="type">unsigned</span> <span class="type">long</span>, addr, ...)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> ksys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的这个函数的调用链路如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(mmap</span><br><span class="line">-&gt; ksys_mmap_pgoff</span><br><span class="line">---&gt; vm_mmap_pgoff</span><br><span class="line">------&gt; do_mmap_pgoff</span><br><span class="line">--------&gt; do_mmap</span><br></pre></td></tr></table></figure>
<p>在 do_mmap 函数中，对输入的 MAP_SHARED 进行了处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:mm/mmap.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> prot,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">vm_flags_t</span> vm_flags,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> *populate,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> list_head *uf)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果包含 MAP_SHARED，则对要申请的虚拟内存设置一个 VM_SHARED</span></span><br><span class="line"> <span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">  <span class="keyword">case</span> MAP_SHARED:</span><br><span class="line">  <span class="keyword">case</span> MAP_SHARED_VALIDATE:</span><br><span class="line">   vm_flags |= VM_SHARED | VM_MAYSHARE; </span><br><span class="line">   ... </span><br><span class="line"> &#125; </span><br><span class="line"> ... </span><br><span class="line"></span><br><span class="line"> addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 flag 包含了 MAP_SHARED，则对要申请的虚拟内存设置一个 VM_SHARED。该标记指明的是要申请一个可以跨进程共享的内存块。接下来进入 mmap_region 中申请虚拟内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:mm/mmap.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">mmap_region</span><span class="params">(<span class="keyword">struct</span> file *file, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 申请虚拟内存vma</span></span><br><span class="line"> vma = vm_area_alloc(mm);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// vma初始化</span></span><br><span class="line"> vma-&gt;vm_start = addr;</span><br><span class="line"> vma-&gt;vm_end = addr + len;</span><br><span class="line"> vma-&gt;vm_flags = vm_flags;</span><br><span class="line"> vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);</span><br><span class="line"> vma-&gt;vm_pgoff = pgoff;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加入到进程的虚拟内存 vma 链表中来</span></span><br><span class="line"> vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程的虚拟内存地址空间在内核底层中就是由这样一个个的 vma 来组成的。每一个 vma 都声明的是进程虚拟地址中的某一段地址范围已经分配出去了。在 mmap_region 函数中申请了 vma，并在内核中将其管理了起来。</p>
<p>这里注意我们在申请共享内存的时候，给 vma 是带了 VM_SHARED 标记的。带了这个标记的 vma和普通的虚拟内存不一样。后面在发生缺页中断申请物理内存的时候，在不同的进程间是可以对应到同一块物理内存的。所以可以实现进程间的共享。</p>
<p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/BBjAFF4hcwpfibKtKUONu125vkLvMX4gxPt0XSxtJ5KM6XoyTNGx2oY4lCKGcQ3eBxfRufjnx0Envfg0PuXbp0A/640?wx_fmt=png&amp;from=appmsg" alt="img"></p>
<p>所以真正让进程之间可以共享内存的是这个带 VM_SHARED 的 vma。</p>
<h2 id="三、发送方发送文件句柄"><a href="#三、发送方发送文件句柄" class="headerlink" title="三、发送方发送文件句柄"></a>三、发送方发送文件句柄</h2><p>发送方在使用 memfd_create 创建出来内存文件，并用 mmap 为其申请可跨进程共享的内存后。接着就可以通过 Unix Domain Socket 中对应的 sendmsg 方法将这个共享内存文件的句柄发送出来。如下是发送的代码示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">send_fd</span><span class="params">(<span class="type">int</span> conn, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把文件句柄放到消息中来</span></span><br><span class="line">    *((<span class="type">int</span> *) CMSG_DATA(CMSG_FIRSTHDR(&amp;msgh))) = fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送出去</span></span><br><span class="line">    sendmsg(conn, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendmsg 又是一个内核提供的系统调用，它位于 net/socket.c 文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/socket.c</span></span><br><span class="line">SYSCALL_DEFINE3(sendmsg, <span class="type">int</span>, fd, <span class="keyword">struct</span> user_msghdr __user *, msg, <span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> __sys_sendmsg(fd, msg, flags, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的调用路径如下</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(sendmsg, ...)</span><br><span class="line">-&gt; __sys_sendmsg</span><br><span class="line">---&gt; ___sys_sendmsg</span><br><span class="line">-----&gt; ____sys_sendmsg</span><br><span class="line">-------&gt; sock_sendmsg</span><br><span class="line">---------&gt; sock_sendmsg_nosec</span><br><span class="line">-----------&gt; unix_stream_sendmsg</span><br></pre></td></tr></table></figure>
<p>在 unix_stream_sendmsg 中执行了真正的发送。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/unix/af_unix.c </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unix_stream_sendmsg</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *msg, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 把文件描述符指向的文件信息复制到 scm_cookie 中</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">scm_cookie</span> <span class="title">scm</span>;</span></span><br><span class="line"> scm_send(sock, msg, &amp;scm, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不断构建数据包发送，直到发送完毕</span></span><br><span class="line">    <span class="keyword">while</span> (sent &lt; len) &#123;</span><br><span class="line">     <span class="comment">// 申请一块缓存区</span></span><br><span class="line">     skb = sock_alloc_send_pskb(sk, size - data_len, data_len,</span><br><span class="line">        msg-&gt;msg_flags &amp; MSG_DONTWAIT, &amp;err,</span><br><span class="line">        get_order(UNIX_SKB_FRAGS_SZ));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 拷贝数据到 skb</span></span><br><span class="line">     err = unix_scm_to_skb(&amp;scm, skb, !fds_sent);</span><br><span class="line">     err = skb_copy_datagram_from_iter(skb, <span class="number">0</span>, &amp;msg-&gt;msg_iter, size);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 直接把 skb 放到对端的接收队列中</span></span><br><span class="line">     skb_queue_tail(&amp;other-&gt;sk_receive_queue, skb);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//发送完毕回调</span></span><br><span class="line">  other-&gt;sk_data_ready(other);</span><br><span class="line">  sent += size;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 unix_stream_sendmsg 中申请了个 skb 缓存区，然后把<strong>要发送的文件句柄</strong>等数据都塞到里面，最后调用 skb_queue_tail 直接把 skb 放到 Unix Domain Socket 连接另一端的接收队列中了。</p>
<p>这里注意文件句柄只有在当前进程内才是有意义的。如果直接发送 fd 出去，接收方是没有办法使用的。所以在 scm_send 函数中，重要的逻辑<strong>是把 fd 对应的 struct file 的指针给找了出来，放到待发送的数据里面了</strong>。只有 file 这种内核级的对象接收方才能使用。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scm_send</span><br><span class="line">-&gt; __scm_send</span><br><span class="line">---&gt; scm_fp_copy</span><br></pre></td></tr></table></figure>
<p>在 scm_fp_copy 中根据 fd 把 file 给找了出来。它的指针会被放到发送数据中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/core/scm.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">scm_fp_copy</span><span class="params">(<span class="keyword">struct</span> cmsghdr *cmsg, <span class="keyword">struct</span> scm_fp_list **fplp)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">//把每一个要发送的 fd 对应的 file 给找出来</span></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; num; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">int</span> fd = fdp[i];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || !(file = fget_raw(fd)))</span><br><span class="line">   <span class="keyword">return</span> -EBADF;</span><br><span class="line">  *fpp++ = file;</span><br><span class="line">  fpl-&gt;count++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、接收方接收文件"><a href="#四、接收方接收文件" class="headerlink" title="四、接收方接收文件"></a>四、接收方接收文件</h3><p>接下来接收方就可以通过 recvmsg 来接收发送方发送过来的文件了。recvmsg 系统会调用到 unix_stream_read_generic 中，然后在这个函数中把 skb 给取出来。</p>
<p><img src="/img/loading.gif" data-original="https://mmbiz.qpic.cn/sz_mmbiz_png/BBjAFF4hcwpfibKtKUONu125vkLvMX4gxHku9TqiaPZeMFIr9E10kJuTrruiaxJbSJF9ibGgeyENYYhEeuCf9CN03Q/640?wx_fmt=png&amp;from=appmsg" alt="img"></p>
<p>下面是接收函数核心 unix_stream_read_generic 的源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/unix/af_unix.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unix_stream_read_generic</span><span class="params">(<span class="keyword">struct</span> unix_stream_read_state *state,</span></span><br><span class="line"><span class="params">        <span class="type">bool</span> freezable)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 拿出一个 skb</span></span><br><span class="line">  last = skb = skb_peek(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">if</span> (state-&gt;msg)</span><br><span class="line">  scm_recv(sock, state-&gt;msg, &amp;scm, flags);</span><br><span class="line"> <span class="keyword">return</span> copied ? : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 skb 拿出来后，还需要调用 scm_recv 来把 skb 中包含的文件给找出来。在 scm_recv 中调用 scm_detach_fds。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/core/scm.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">scm_detach_fds</span><span class="params">(<span class="keyword">struct</span> msghdr *msg, <span class="keyword">struct</span> scm_cookie *scm)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fdmax; i++) &#123;</span><br><span class="line">  err = receive_fd_user(scm-&gt;fp-&gt;fp[i], cmsg_data + i, o_flags);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 scm-&gt;fp-&gt;fp[i] 中包含的是发送方发送过来的 struct file 指针。这样文件就取出来了。当然 struct file 是个内核态的对象，用户没有办法使用。所以还需要再为其在新的进程中申请一个文件句柄，然后返回。本文来自公众号「开发内功修炼」。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:fs/file.c</span></span><br><span class="line"><span class="type">int</span> __receive_fd(<span class="keyword">struct</span> file *file, <span class="type">int</span> __user *ufd, <span class="type">unsigned</span> <span class="type">int</span> o_flags)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//申请一个新的文件描述符</span></span><br><span class="line"> new_fd = get_unused_fd_flags(o_flags);</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//关联文件</span></span><br><span class="line"> fd_install(new_fd, get_file(file));</span><br><span class="line"> <span class="keyword">return</span> new_fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>共享内存发送方进程的开发过程基本分 memfd_create 创建内存文件、mmap 申请共享内存、Unix Domain Socket 发送文件句柄三步。</p>
<ul>
<li>第一步，memfd_create 系统调用的主要逻辑有两个，一是调用 get_unused_fd_flags 申请一个没使用过的文件句柄，二是调用 shmem_file_setup 创建一个共享内存文件。</li>
<li>第二步，mmap 系统调用在调用它的时候传入的第三个 flag 参数是 MAP_SHARED，该参数是申请一块跨进程可共享访问的物理内存。</li>
<li>第三步，接着通过 Unix Domain Socket 中对应的 sendmsg 方法将这个共享内存文件的句柄发送出去。在发送时，把文件句柄对应的 struct file 指针找到并放到要封装的 skb 数据包中了。</li>
</ul>
<p>接收方进程的主要实现原理是 recvmsg 系统调用。在这个系统调用中，内核会把发送方发送过来的 struct file 指针取出来，然后再在当前进程下为其申请一个新的文件句柄。这个文件句柄返回给用户进程后，用户进程就可以用它来和另外一个进程共享地访问同一块内存了。</p>
<p>总体来看，共享内存本质上共享的是内核对象 struct file，通过在不同的进程之间使用同一个 struct file 来实现的共享。当然也得需要在虚拟内存对象 vma 带上 VM_SHARED 标记来支持。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2023/12/12/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" data-id="cm1em9i5o00012jwphrmee1tu" data-title="Linux进程间通信" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python入门语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/12/python%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2023-12-11T16:00:00.000Z" itemprop="datePublished">2023-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>►<a class="article-category-link" href="/categories/python/%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/">入门语法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/12/python%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/">python入门语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、类的定义"><a href="#一、类的定义" class="headerlink" title="一、类的定义"></a>一、类的定义</h2><p><em>foo，单下划线开头： protected 类型的变量或方法，只允许其本身与子类进行访问，不能用于 from module import *<br>\</em>_foo，双下划线：私有类型(private)的变量或方法, 只允许这个类本身进行访问<br>foo，正常的 public 变量<br>def __foo__(): # 使用__xx__定义的一般是保留的，如__init()__，与c的关键字类似，不建议在日常业务或使用中写这种风格的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TClass</span>:</span><br><span class="line">    _foo = <span class="number">0</span>       <span class="comment"># 单下划线开头： protected 类型的变量或方法，只允许其本身与子类进行访问，不能用于 from module import *</span></span><br><span class="line">    __foo = <span class="number">0</span>      <span class="comment"># 双下划线：私有类型(private)的变量或方法, 只允许这个类本身进行访问</span></span><br><span class="line">    foo = <span class="number">0</span>     <span class="comment"># 正常的 public 变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__foo__</span>(): <span class="comment"># 使用__xx__定义的一般是保留的，如__init()__，与c的关键字类似，不建议在日常业务或使用中写这种风格的代码</span></span><br><span class="line">        <span class="comment"># todo</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="二、类的继承"><a href="#二、类的继承" class="headerlink" title="二、类的继承"></a>二、类的继承</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TClass</span>(A, B): <span class="comment"># 支持多继承</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h2 id="python的字典"><a href="#python的字典" class="headerlink" title="python的字典"></a>python的字典</h2><p>KV类型的数据结构，使用案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">    (<span class="string">&quot;12944551388&quot;</span>, <span class="number">16</span>),(<span class="string">&quot;12936786244&quot;</span>, <span class="number">12</span>),(<span class="string">&quot;12944540156&quot;</span>, <span class="number">12</span>),(<span class="string">&quot;12944547158&quot;</span>, <span class="number">10</span>),(<span class="string">&quot;12936764315&quot;</span>, <span class="number">8</span>),(<span class="string">&quot;12944555064&quot;</span>, <span class="number">8</span>),(<span class="string">&quot;12936773718&quot;</span>, <span class="number">7</span>),(<span class="string">&quot;12944546248&quot;</span>, <span class="number">7</span>),</span><br><span class="line">    (<span class="string">&quot;12944553664&quot;</span>, <span class="number">7</span>),(<span class="string">&quot;12944553664&quot;</span>, <span class="number">6</span>),(<span class="string">&quot;12936764315&quot;</span>, <span class="number">5</span>),(<span class="string">&quot;12936769236&quot;</span>, <span class="number">4</span>),(<span class="string">&quot;12944548117&quot;</span>, <span class="number">4</span>),(<span class="string">&quot;12936766915&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12936783342&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12944540156&quot;</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="string">&quot;12944542490&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12944543864&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12944553778&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12936786244&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;12944538208&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944538637&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944540736&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944546248&quot;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">&quot;12944549839&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944555064&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944555064&quot;</span>, <span class="number">1</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> result:</span><br><span class="line">        result[key] += value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result[key] = value</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/xyiling/xyiling.github.io/2023/12/12/python%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/" data-id="cm1em9i6c000j2jwp072dg318" data-title="python入门语法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python%E3%80%81%E7%B1%BB%E3%80%81%E5%AD%97%E5%85%B8/" rel="tag">python、类、字典</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/%E5%BA%8F%E5%88%97%E5%8C%96/">序列化</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/shell/">shell</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/python/%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/">入门语法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/">交换网络</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E4%BC%A0%E8%BE%93/">帧传输</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E4%BC%A0%E8%BE%93/%E4%BF%A1%E5%8F%B7/">信号</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E4%BC%A0%E8%BE%93/%E4%BF%A1%E5%8F%B7/%E7%BC%96%E7%A0%81/">编码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/%E5%B8%A7%E4%BC%A0%E8%BE%93/%E4%BF%A1%E5%8F%B7/%E7%BC%96%E7%A0%81/%E8%B0%83%E5%88%B6/">调制</a></li></ul></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IP-%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84-%E7%BD%91%E7%BB%9C%E5%B1%82/" rel="tag">IP, 头部结构, 网络层</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust/" rel="tag">Rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux-kernel-boot/" rel="tag">linux, kernel, boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E3%80%81%E7%B1%BB%E3%80%81%E5%AD%97%E5%85%B8/" rel="tag">python、类、字典</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C-%E5%B8%A7%E4%BC%A0%E8%BE%93-%E4%BF%A1%E5%8F%B7-%E7%BC%96%E7%A0%81-%E8%B0%83%E5%88%B6/" rel="tag">交换网络, 帧传输, 信号, 编码, 调制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/" rel="tag">服务器项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/IP-%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84-%E7%BD%91%E7%BB%9C%E5%B1%82/" style="font-size: 10px;">IP, 头部结构, 网络层</a> <a href="/tags/Rust/" style="font-size: 10px;">Rust</a> <a href="/tags/linux-kernel-boot/" style="font-size: 10px;">linux, kernel, boot</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/python%E3%80%81%E7%B1%BB%E3%80%81%E5%AD%97%E5%85%B8/" style="font-size: 10px;">python、类、字典</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C-%E5%B8%A7%E4%BC%A0%E8%BE%93-%E4%BF%A1%E5%8F%B7-%E7%BC%96%E7%A0%81-%E8%B0%83%E5%88%B6/" style="font-size: 10px;">交换网络, 帧传输, 信号, 编码, 调制</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">服务器项目</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/06/%E6%90%AD%E5%BB%BApython%E9%A1%B9%E7%9B%AE/">搭建python项目</a>
          </li>
        
          <li>
            <a href="/2024/08/26/grep%E3%80%81sed%E3%80%81awk%E4%B8%8E%E6%AD%A3%E5%88%99/">grep、sed、awk与正则</a>
          </li>
        
          <li>
            <a href="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/">计算机网络-物理层概念</a>
          </li>
        
          <li>
            <a href="/2024/08/05/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">shell脚本学习笔记</a>
          </li>
        
          <li>
            <a href="/2024/08/01/java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">Java序列化和反序列化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 xiaoyiling<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body>
</html>