<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>B+树概念</title>
      <link href="/2024/08/01/B+%E6%A0%91%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/08/01/B+%E6%A0%91%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="B-树概念"><a href="#B-树概念" class="headerlink" title="B+树概念"></a>B+树概念</h2><p>阶数m：分支数量，根据节点类型不同，m的取值不同。<br>对于非叶子结点，m&gt;&#x3D;$\lceil m&#x2F;2 \rceil$,m&lt;&#x3D;m-1。解释：一棵m阶b+树，非叶子结点最多含有m个分支（子结点），且最少含有m&#x2F;2个分支（子结点）。<br>对于叶子节点，子结点数量最大可取m，最小还是$\lceil m&#x2F;2 \rceil$</p><p>m阶b+树，一个结点最多可以有m-1个关键字，最少$\lceil m&#x2F;2 \rceil$个关键字。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java传值方式</title>
      <link href="/2024/08/01/java%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/08/01/java%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>java 只支持值传递，没有引用传递方式，即使传入对象，那也是对象的地址，地址也是简单数据类型，也就是值传递，所以如果一个函数交换两个对象的地址，是不会成功的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">xiaoZhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">xiaoLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        swap(xiaoZhang, xiaoLi);</span><br><span class="line">        System.out.println(<span class="string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">temp</span> <span class="operator">=</span> person1;</span><br><span class="line">        person1 = person2;</span><br><span class="line">        person2 = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;person1:&quot;</span> + person1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;person2:&quot;</span> + person2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person1:小李</span><br><span class="line">person2:小张</span><br><span class="line">xiaoZhang:小张</span><br><span class="line">xiaoLi:小李</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/30/custom/css/background/"/>
      <url>/2024/07/30/custom/css/background/</url>
      
        <content type="html"><![CDATA[#web_bg {    background: -webkit-linear-gradient(      0deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );    background: -moz-linear-gradient(      0deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );    background: -o-linear-gradient(      0deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );    background: -ms-linear-gradient(      0deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );    background: linear-gradient(      90deg,      rgba(247, 149, 51, 0.1) 0,      rgba(243, 112, 85, 0.1) 15%,      rgba(239, 78, 123, 0.1) 30%,      rgba(161, 102, 171, 0.1) 44%,      rgba(80, 115, 184, 0.1) 58%,      rgba(16, 152, 173, 0.1) 72%,      rgba(7, 179, 155, 0.1) 86%,      rgba(109, 186, 130, 0.1) 100%    );  }  ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/11/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/07/11/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="shell脚本学习"><a href="#shell脚本学习" class="headerlink" title="shell脚本学习"></a>shell脚本学习</h1><p>[toc]</p><h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2><ol><li>使用$1、$2…表示参数（这在脚本语言中称为位置参数），需要注意当参数个数超过10个（包括10），需要使用花括号，如${10}， 此外$0表示脚本或程序的名称；</li><li>使用$?表示上一条命令的执行返回值，0表示正常返回；</li><li>使用$#表示参数个数，$0将不被包含在内，即bash test.sh 0 1 2 3，使用echo $#将得到4，而不是5；</li><li>使用$$获取当前进程的进程号pid，如:93655；</li><li>使用$@和$*获取所有参数，其中$*会将所有的参数当做一整个字符串，遍历时只会循环一遍；</li></ol><h2 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h2><ol><li>‘’单引号表示输出原始字符串，单引号内部的数据不会经过转义，但双引号””会；</li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol><li>$[1 + 1]、$((1 + 1))、expr 1 + 1 三种方式都可以进行四则运算；特殊地，expr四则运算的符号必须用空格隔开。</li><li>特殊地，**表示乘方，如2**3表示2^3&#x3D;8；</li></ol><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ol><li>条件判断语句为[ ]，其中的符号包括：&#x3D;（等于）、!&#x3D;（不等于）、-z（字符串长度为零）、-n（字符串长度不为零）、-e（文件存在）、-f（文件存在且为普通文件）、-d（文件存在且为目录）、-r（文件存在且可读）、-w（文件存在且可写）、-x（文件存在且可执行）；</li><li>条件判断语句可以与&amp;&amp;（与）、||（或）、！（非）结合使用；</li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ol><li>for循环的语法为：for var in item1 item2… itemN；</li><li>while循环的语法为：while condition；</li><li>until循环的语法为：until condition；</li><li>break、continue语句用于跳出循环；</li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>函数的定义语法为：function name { commands; }；</li><li>函数调用语法为：name param1 param2…；</li><li>函数返回值使用return语句，返回值只能是数字、字符串、数组、字典等简单数据类型；</li></ol><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ol><li>输出到终端使用echo命令，如echo “Hello World!”；</li><li>输出到文件使用重定向符号&gt;，如echo “Hello World!” &gt; output.txt；</li><li>输入从终端使用read命令，如read name；</li><li>输入从文件使用&lt;符号，如cat input.txt | while read line; do echo $line; done；</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>数组的定义语法为：array_name&#x3D;(item1 item2… itemN)；</li><li>数组的访问语法为：${array_name[index]}，其中index从0开始；</li><li>字典的定义语法为：declare -A dict_name&#x3D;([“key1”]&#x3D;”value1” [“key2”]&#x3D;”value2”…)；</li><li>字典的访问语法为：${dict_name[“key”]}；</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>赋值不能空格，如a&#x3D;1，不能写成a &#x3D; 1；</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
      <url>/2024/07/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统概念整理"><a href="#操作系统概念整理" class="headerlink" title="操作系统概念整理"></a>操作系统概念整理</h1><h2 id="spooling技术"><a href="#spooling技术" class="headerlink" title="spooling技术"></a>spooling技术</h2><p>spooling技术是指将输入输出操作分离，将输入输出操作的请求存储在缓冲区中，并在需要时进行处理。</p><p>spooling技术的优点是：</p><ol><li>减少了系统的开销，因为不需要等待输入输出操作的完成。</li><li>提高了系统的并发性，因为可以同时处理多个输入输出操作。</li><li>简化了系统的设计，因为不需要考虑各种输入输出操作的细节。</li></ol><h2 id="覆盖交换技术"><a href="#覆盖交换技术" class="headerlink" title="覆盖交换技术"></a>覆盖交换技术</h2><ol><li>覆盖交换技术是指将内存中的程序和数据分割成多个区域，并在需要时进行交换。</li><li>覆盖交换技术的优点是：<ul><li>减少了内存的使用率，因为可以将程序和数据分割成多个区域，使得内存中有更多的空闲空间。</li><li>提高了内存的利用率，因为可以将程序和数据分割成多个区域，使得内存中有更多的程序和数据可以运行。</li><li>简化了内存管理，因为可以将程序和数据分割成多个区域，并在需要时进行交换，不需要考虑内存碎片的问题。</li></ul></li><li>覆盖交换技术的缺点是：<ul><li>增加了系统开销，因为需要进行内存的分配和交换。</li><li>降低了系统的并发性，因为交换操作需要暂停整个系统。</li></ul></li></ol><h2 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h2><ol><li>虚拟存储技术是指将一个物理存储器分割成多个逻辑存储器，并在需要时进行映射。</li><li>虚拟存储技术的优点是：<ul><li>减少了物理存储器的使用率，因为可以将物理存储器分割成多个逻辑存储器，使得物理存储器中有更多的空闲空间。</li><li>提高了物理存储器的利用率，因为可以将物理存储器分割成多个逻辑存储器，使得物理存储器中有更多的程序和数据可以运行。</li><li>简化了物理存储器管理，因为可以将物理存储器分割成多个逻辑存储器，并在需要时进行映射，不需要考虑物理碎片的问题。</li></ul></li><li>虚拟存储技术的缺点是：<ul><li>增加了系统开销，因为需要进行物理存储器的分配和映射。</li><li>降低了系统的并发性，因为映射操作需要暂停整个系统。</li></ul></li></ol><h2 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h2><ol><li>虚拟内存技术是指将物理内存分割成多个虚拟内存，并在需要时进行映射。</li><li>虚拟内存技术的优点是：<ul><li>减少了系统的开销，因为可以将物理内存分割成多个虚拟内存，使得系统中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>虚拟内存技术的缺点是：<ul><li>降低了物理内存的利用率，因为虚拟内存需要占用物理内存。</li><li>增加了物理内存的碎片，因为虚拟内存需要占用物理内存。</li></ul></li></ol><h2 id="通道技术"><a href="#通道技术" class="headerlink" title="通道技术"></a>通道技术</h2><ol><li>通道技术是指将输入输出操作分离，并通过专用通道进行传输。</li><li>通道技术的优点是：<ul><li>减少了系统的开销，因为不需要等待输入输出操作的完成。</li><li>提高了系统的并发性，因为可以同时处理多个输入输出操作。</li><li>简化了系统的设计，因为不需要考虑各种输入输出操作的细节。</li></ul></li><li>通道技术的缺点是：<ul><li>降低了系统的可靠性，因为通道可能会出现错误。</li><li>增加了系统的复杂性，因为需要设计专用通道。</li></ul></li></ol><h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><ol><li>缓冲技术是指将输入输出操作分离，并通过缓冲区进行传输。</li><li>缓冲技术的优点是：<ul><li>减少了系统的开销，因为不需要等待输入输出操作的完成。</li><li>提高了系统的并发性，因为可以同时处理多个输入输出操作。</li><li>简化了系统的设计，因为不需要考虑各种输入输出操作的细节。</li></ul></li><li>缓冲技术的缺点是：<ul><li>降低了系统的可靠性，因为缓冲区可能会出现错误。</li><li>增加了系统的复杂性，因为需要设计缓冲区。</li></ul></li></ol><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ol><li>页面置换算法是指当内存中没有空闲空间时，选择一页或多页页面进行替换。</li><li>页面置换算法的优点是：<ul><li>减少了系统的开销，因为可以将内存中的程序和数据分割成多个区域，使得内存中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>页面置换算法的缺点是：<ul><li>降低了系统的性能，因为频繁的页面置换会导致系统的响应时间变长。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h3 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h3><ol><li>最佳置换算法是指选择被访问最少的页面进行替换。</li><li>最佳置换算法的优点是：<ul><li>降低了系统的性能，因为可以减少页面置换的次数。</li><li>提高了系统的命中率，因为可以减少页面置换的次数。</li></ul></li><li>最佳置换算法的缺点是：<ul><li>降低了系统的并发性，因为需要等待被置换的页面被访问。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h3 id="最近最少使用置换算法"><a href="#最近最少使用置换算法" class="headerlink" title="最近最少使用置换算法"></a>最近最少使用置换算法</h3><ol><li>最近最少使用置换算法是指选择最近被访问的页面进行替换。</li><li>最近最少使用置换算法的优点是：<ul><li>降低了系统的性能，因为可以减少页面置换的次数。</li><li>提高了系统的命中率，因为可以减少页面置换的次数。</li></ul></li><li>最近最少使用置换算法的缺点是：<ul><li>降低了系统的并发性，因为需要等待被置换的页面被访问。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h3 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h3><ol><li>先进先出置换算法是指选择最先进入内存的页面进行替换。</li><li>先进先出置换算法的优点是：<ul><li>降低了系统的性能，因为可以减少页面置换的次数。</li><li>提高了系统的命中率，因为可以减少页面置换的次数。</li></ul></li><li>先进先出置换算法的缺点是：<ul><li>降低了系统的并发性，因为需要等待被置换的页面被访问。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h3 id="时钟置换算法"><a href="#时钟置换算法" class="headerlink" title="时钟置换算法"></a>时钟置换算法</h3><ol><li>时钟置换算法是指选择最近最久未使用页面进行替换。</li><li>时钟置换算法的优点是：<ul><li>降低了系统的性能，因为可以减少页面置换的次数。</li><li>提高了系统的命中率，因为可以减少页面置换的次数。</li></ul></li><li>时钟置换算法的缺点是：<ul><li>降低了系统的并发性，因为需要等待被置换的页面被访问。</li><li>增加了系统的复杂性，因为需要设计页面置换算法。</li></ul></li></ol><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><ol><li>虚拟内存管理是指管理虚拟内存，包括分配、映射、置换、回收等操作。</li><li>虚拟内存管理的优点是：<ul><li>减少了系统的开销，因为可以将物理内存分割成多个虚拟内存，使得系统中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>虚拟内存管理的缺点是：<ul><li>降低了物理内存的利用率，因为虚拟内存需要占用物理内存。</li><li>增加了物理内存的碎片，因为虚拟内存需要占用物理内存。</li></ul></li></ol><h2 id="虚拟内存的实现"><a href="#虚拟内存的实现" class="headerlink" title="虚拟内存的实现"></a>虚拟内存的实现</h2><ol><li>虚拟内存的实现是指将物理内存分割成多个虚拟内存，并在需要时进行映射。</li><li>虚拟内存的实现的优点是：<ul><li>减少了系统的开销，因为可以将物理内存分割成多个虚拟内存，使得系统中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>虚拟内存的实现的缺点是：<ul><li>降低了物理内存的利用率，因为虚拟内存需要占用物理内存。</li><li>增加了物理内存的碎片，因为虚拟内存需要占用物理内存。</li></ul></li></ol><h2 id="缓冲池技术"><a href="#缓冲池技术" class="headerlink" title="缓冲池技术"></a>缓冲池技术</h2><ol><li>缓冲池技术是指将内存中的程序和数据分割成多个区域，并在需要时进行缓冲。</li><li>缓冲池技术的优点是：<ul><li>减少了系统的开销，因为可以将程序和数据分割成多个区域，使得内存中有更多的空闲空间。</li><li>提高了系统的并发性，因为可以同时运行多个虚拟内存。</li><li>简化了系统的设计，因为不需要考虑物理内存的细节。</li></ul></li><li>缓冲池技术的缺点是：<ul><li>降低了物理内存的利用率，因为缓冲池需要占用物理内存。</li><li>增加了物理内存的碎片，因为缓冲池需要占用物理内存。</li></ul></li></ol><h2 id="虚拟内存与缓冲池的区别"><a href="#虚拟内存与缓冲池的区别" class="headerlink" title="虚拟内存与缓冲池的区别"></a>虚拟内存与缓冲池的区别</h2><ol><li>虚拟内存与缓冲池的区别是：<ul><li>虚拟内存是将物理内存分割成多个虚拟内存，并在需要时进行映射。</li><li>缓冲池是将内存中的程序和数据分割成多个区域，并在需要时进行缓冲。</li></ul></li></ol><h2 id="创建进程的四个情况"><a href="#创建进程的四个情况" class="headerlink" title="创建进程的四个情况"></a>创建进程的四个情况</h2><ol><li>用户登录</li><li>提供服务</li><li>作业调度</li><li>应用请求</li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
      <url>/2024/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构概念整理"><a href="#数据结构概念整理" class="headerlink" title="数据结构概念整理"></a>数据结构概念整理</h1><h2 id="如何通过c的数组实现hash操作？"><a href="#如何通过c的数组实现hash操作？" class="headerlink" title="如何通过c的数组实现hash操作？"></a>如何通过c的数组实现hash操作？</h2><p>给定一个数组长度为n，定义一个hash函数f(key) &#x3D; key % n，其中key为待查找的关键字。</p><p>通过hash函数计算出key对应的数组下标i，将数组下标i处的值置为key。</p><p>查找时，通过hash函数计算出key对应的数组下标i，并比较数组下标i处的值与key是否相等。如果相等，则说明查找成功；否则，说明查找失败。</p><p>如果要计算一个元素的个数，且在o(n)时间完成，就可以使用这个hash算法。   </p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>左根右，根叶黑，黑路同，不红红。</p><ul><li>左根右：左孩子 &lt; 根节点 &lt; 右孩子</li><li>根叶黑：根节点是黑色，叶子节点是黑色</li><li>黑路同：从任意节点到叶子节点的路径上，黑色节点数量相同</li><li>不红红：不会有红孩子的子节点还是红孩子</li></ul><p>红黑树有自平衡的机制，插入删除操作后，树的高度不会超过log(n)，也就意味着查找长度为O(log(n))。</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>哈夫曼树是一种二叉树，其中每个节点都是一个叶子节点或一个内部节点，且左右子树的权值之和最小。</p><p>哈夫曼树的生成过程：</p><ol><li>首先，将所有字符及其出现的频率作为叶子节点，构造一棵二叉树。</li><li>然后，从根节点开始，将两个权值最小的子树合并为一个新的内部节点，并将原来的两个子树作为左右子树。</li><li>重复步骤2，直到所有的叶子节点都在同一棵树上。</li></ol><h3 id="哈夫曼数的特性"><a href="#哈夫曼数的特性" class="headerlink" title="哈夫曼数的特性"></a>哈夫曼数的特性</h3><ul><li>任意一颗哈夫曼树都对应唯一的哈夫曼编码，且编码长度最短。</li><li>每一个编码都不能是其他编码的前缀。如0，10，110，1110，11110等。<br>  这样如果有一个编码：0 10 110 1110 </li><li>哈夫曼树的高度等于字符的个数。</li><li>哈夫曼树的平均路径长度等于字符的个数。</li></ul><h3 id="哈夫曼bergman编码"><a href="#哈夫曼bergman编码" class="headerlink" title="哈夫曼bergman编码"></a>哈夫曼bergman编码</h3><p>哈夫曼bergman编码是一种变长编码，它可以对任意长度的二进制串进行编码，且编码长度最短。</p><h3 id="哈夫曼编码的应用"><a href="#哈夫曼编码的应用" class="headerlink" title="哈夫曼编码的应用"></a>哈夫曼编码的应用</h3><ul><li>数据压缩：将原始数据经过哈夫曼编码后，编码后的串的长度通常比原始数据长度小很多。</li><li>数据加密：哈夫曼编码可以对数据进行加密，使得接收方无法直接解读数据内容。</li><li>数据校验：哈夫曼编码可以对数据进行校验，检测数据是否被篡改。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
      <url>/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理概念整理"><a href="#计算机组成原理概念整理" class="headerlink" title="计算机组成原理概念整理"></a>计算机组成原理概念整理</h1><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><h4 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h4><p>基础数据：12345678H</p><ul><li>大端：高位存放在低地址，和自然阅读的顺序一致，存放结果：12H 34H 56H 78H</li><li>小端：低位存放在低地址，和计算机数组的顺序一致，存放结果：78H 56H 34H 12H</li></ul><h2 id="bcd码"><a href="#bcd码" class="headerlink" title="bcd码"></a>bcd码</h2><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><p>BCD码是一种二进制编码，它将8位二进制数的低4位作为一个数字，高4位作为一个数字的进位。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/06/24/archlinux%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93/"/>
      <url>/2024/06/24/archlinux%E5%AE%89%E8%A3%85%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="archlinux安装总结"><a href="#archlinux安装总结" class="headerlink" title="archlinux安装总结"></a>archlinux安装总结</h1><h2 id="一、下载iso文件"><a href="#一、下载iso文件" class="headerlink" title="一、下载iso文件"></a>一、下载iso文件</h2><h2 id="二、校验签名"><a href="#二、校验签名" class="headerlink" title="二、校验签名"></a>二、校验签名</h2><p>通过http下载到的ISO镜像文件，很可能会受到故意的污染，带来潜在的威胁。</p><ol><li><p>安装<a href="https://wiki.archlinux.org/title/GnuPG">GnuPG</a></p><p>GnuPG是一个完整的、免费的OpenPGP标准实现，支持对数据的加密和签名。</p></li><li><p><a href="https://mirrors.nju.edu.cn/archlinux/iso/2024.03.29/archlinux-2024.03.29-x86_64.iso.sig">下载签名</a></p><p>校验签名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.iso.sig</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、正式安装"><a href="#三、正式安装" class="headerlink" title="三、正式安装"></a>三、正式安装</h2><ol><li><p>关闭安全启动</p><p>安装完成后可以重新开启安全启动。</p></li><li><p>设置控制台键盘和字体</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfont ter-132b# archlinux控制台字体存放在/usr/share/kbd/consolefonts/，通过setfont fontname修改控制台点阵字体</span><br></pre></td></tr></table></figure></li><li><p>校验启动模式（UEFI、BIOS）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/firmware/efi/fw_platform_size</span><br></pre></td></tr></table></figure><p>如果返回64，代表运行在32位uefi模式环境下;如果返回32，代表运行在32位uefi环境下。只要支持uefi，BootLoader会使用systemd启动系统。</p><p>如果文件不存在，代表当前环境可能是BIOS（或者说是csm）。</p><p>如果两者都不是，那就要看看主板的手册了。</p></li><li><p>联网</p><ul><li>如果是局域网（wifi），需要保证网卡没有被关闭</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rfkill</span><br><span class="line">---------------------------------------</span><br><span class="line">ID TYPE      DEVICE      SOFT      HARD</span><br><span class="line"> 0 bluetooth hci0   unblocked unblocked</span><br><span class="line"> 1 wlan      phy0   unblocked unblocked</span><br></pre></td></tr></table></figure><p>如果HARD下是blocked（硬件级关闭），手动开启；</p><p>如果SOFT下是blocked（可以通过命令开启），使用<code>rfkill unblock wlan</code></p><ul><li><p>使用<code>iwctl</code>命令联网</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iwctl</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">device list <span class="comment"># 显示可联网的设备列表</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果设备关闭，使用下面的命令开启设备</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">device name set-property Powered on</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">adapter adapter set-property Powered on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扫描网络</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">station name scan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示扫描到的网络</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">station name get-networks</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接到指定网络</span></span><br><span class="line"><span class="meta prompt_">[iwd]$ </span><span class="language-bash">station name connect SSID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是有密码的wifi，使用下面的命令连接目标wifi</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iwctl --passphrase 密码 station 设备 connect SSID</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置系统时间<code>timedatectl</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure></li><li><p>分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk # 或者 fdisk -l</span><br></pre></td></tr></table></figure><p>需要以下的分区：</p><blockquote><ol><li>root分区 &#x2F;</li><li>EFI分区（如果是多系统，使用已有的efi分区就行）</li><li>home分区</li><li>交换分区（交换文件，需要文件系统支持）</li></ol></blockquote><p>6.1 使用<code>cfdisk /dev/nvme0n1</code>对磁盘进行分区。</p><p>GPT格式各分区建议大小：</p><table><thead><tr><th align="center">挂载点</th><th align="center">分区</th><th align="center">分区类型</th><th align="center">分区大小</th></tr></thead><tbody><tr><td align="center"><code>/mnt/boot</code></td><td align="center"><code>/dev/EFI分区</code></td><td align="center">EFI system partition</td><td align="center">1 GiB</td></tr><tr><td align="center"><code>[SWAP]</code></td><td align="center"><code>/dev/交换分区</code></td><td align="center">Linux swap</td><td align="center">至少4 GiB</td></tr><tr><td align="center"><code>/mnt</code></td><td align="center"><code>/dev/root分区</code></td><td align="center">Linux x86-64 root (&#x2F;)</td><td align="center">剩余磁盘大小. 至少 23–32 GiB.</td></tr></tbody></table><p>6.2 格式化分区</p><p>root分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkfs.ext4 /dev/root_partition</span></span><br></pre></td></tr></table></figure><p>swap分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkswap /dev/swap_partition</span></span><br></pre></td></tr></table></figure><p>EFI分区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mkfs.fat -F 32 /dev/efi_system_partition</span></span><br></pre></td></tr></table></figure><p>6.3 挂载分区</p><p>挂载root分区到&#x2F;mnt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount /dev/root_partition /mnt</span></span><br></pre></td></tr></table></figure><p>创建剩余的挂载点（如&#x2F;mnt&#x2F;boot），挂载其他分区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount --<span class="built_in">mkdir</span> /dev/efi_system_partition /mnt/boot</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">swapon /dev/swap_partition</span></span><br></pre></td></tr></table></figure></li><li><p>安装系统</p><p>7.1 换源</p><p>在<code>/etc/pacman.d/mirrorlist</code>文件中存放着各个区域对应的软件源。国内直接选出清华源、中科大源、南大源或其他高速源即可。</p><p>7.2 安装基本软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap -K /mnt base linux linux-firmware intel-ucode sof-firmware NetworkManager vim </span><br></pre></td></tr></table></figure><p>7.3 生成fstab文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>7.4 chroot（进入新系统）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>7.5 设置时区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/06/24/gdb_debug/"/>
      <url>/2024/06/24/gdb_debug/</url>
      
        <content type="html"><![CDATA[<h1 id="gdb指令"><a href="#gdb指令" class="headerlink" title="gdb指令"></a>gdb指令</h1><p>read memory: x &#x2F;nfu addr</p><p>n: how many elements to read.<br>f: how to display target data.<br>support format:</p><ul><li>x: data will be display in the form of hex code.</li><li>d: 0, 1, 2, …, nums like decimal.</li><li>u: unsigned int.</li><li>o: \0123, \0254, etc</li><li>t: binary</li><li>a: the same as ‘x’</li><li>i: addr</li><li>c: char</li><li>f: float<br>u: how many elements the addr counts.</li><li>b: 8 bit, 1 byte</li><li>h: 16 bits, 1 word</li><li>w: 32 bits, 2 words</li><li>g: 64 bits, 4 words</li></ul><p>for example:<br>x &#x2F;20cb 0x11223344: read memory address 0x11223344, data will be displayed in the stdout like a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,<br>x &#x2F;20ch 0x11223344: a,c,e,g,i,k,m,o,q,s</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概念</title>
      <link href="/2024/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存置换策略"><a href="#内存置换策略" class="headerlink" title="内存置换策略"></a>内存置换策略</h3><h3 id="belady现象"><a href="#belady现象" class="headerlink" title="belady现象"></a>belady现象</h3><h2 id="CPU管理"><a href="#CPU管理" class="headerlink" title="CPU管理"></a>CPU管理</h2><h2 id="io管理"><a href="#io管理" class="headerlink" title="io管理"></a>io管理</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>rust学习笔记</title>
      <link href="/2024/04/17/rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/17/rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="rust学习笔记"><a href="#rust学习笔记" class="headerlink" title="rust学习笔记"></a>rust学习笔记</h1><h2 id="与其他后端语言的共性"><a href="#与其他后端语言的共性" class="headerlink" title="与其他后端语言的共性"></a>与其他后端语言的共性</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型（栈数据）"><a href="#基本数据类型（栈数据）" class="headerlink" title="基本数据类型（栈数据）"></a>基本数据类型（栈数据）</h4><ol><li>bool</li></ol><p>true和false，大小为1个字节。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_true</span>: <span class="type">bool</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_false</span>: <span class="type">bool</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;is_true: &#123;&#125;&quot;</span>, is_true);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;is_false: &#123;&#125;&quot;</span>, is_false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>int</li></ol><ul><li>i8：有符号8位整数类型</li><li>u8：无符号8位整数类型</li><li>i16：有符号16位整数类型</li><li>u16：无符号16位整数类型</li><li>i32：有符号32位整数类型</li><li>u32：无符号32位整数类型</li><li>i64：有符号64位整数类型</li><li>u64：无符号64位整数类型</li><li>i128：有符号128位整数类型</li><li>u128：无符号128位整数类型</li><li>isize：有符号指针大小整数类型</li><li>usize：无符号指针大小整数类型<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i8</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u16</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">i32</span> = -<span class="number">500</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span>: <span class="type">u64</span> = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b: &#123;&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;&#125;&quot;</span>, c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;d: &#123;&#125;&quot;</span>, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>float<br>f32和f64，遵从ieee754规则，f32是32位浮点数，f64是64位浮点数。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">f32</span> = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f64</span> = <span class="number">2.71828</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>char</li></ol><p>Unicode标量值的32位表示。字符类型的大小为4个字节</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">char</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_emoji</span>: <span class="type">char</span> = <span class="string">&#x27;❤&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;&#125;&quot;</span>, c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;heart_emoji: &#123;&#125;&quot;</span>, heart_emoji);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h4><ol><li>元组（Tuple）<br>将多个不同类型的值组合在一起。元组使用圆括号()表示，其中的值可以通过索引访问。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span>: (<span class="type">String</span>, <span class="type">i32</span>, <span class="type">bool</span>) = (<span class="string">&quot;Alice&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">25</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Name: &#123;&#125;&quot;</span>, person.<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Age: &#123;&#125;&quot;</span>, person.<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Is employed: &#123;&#125;&quot;</span>, person.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>数组（Array）<br>数组是一种固定长度的数据结构，存储相同类型的多个值。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> numbers.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Number: &#123;&#125;&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>String，由一系列Unicode字符组成。可增长的。</p><p>以下是一个字符串的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, Rust!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Message: &#123;&#125;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><ol><li>结构体（Struct）<br>将多个不同类型的值组合在一起形成一个新的类型。结构体使用struct关键字定义，并可以包含字段（field）和方法（method）。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Area: &#123;&#125;&quot;</span>, rect.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>枚举（Enum）<br>枚举是一种自定义的数据类型，它可以表示多个可能的值。枚举使用enum关键字定义，并可以包含不同的变体（variant）。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Banana,</span><br><span class="line">    Orange,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fruit</span>: Fruit = Fruit::Apple;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> fruit &#123;</span><br><span class="line">        Fruit::Apple =&gt; <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s an apple!&quot;</span>),</span><br><span class="line">        Fruit::Banana =&gt; <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s a banana!&quot;</span>),</span><br><span class="line">        Fruit::Orange =&gt; <span class="built_in">println!</span>(<span class="string">&quot;It&#x27;s an orange!&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h3><ol><li>切片（Slice）<br>切片是对数组或字符串的引用，它允许我们引用集合中的一部分而不用拷贝整个集合。切片使用&amp;符号和范围表示。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">i32</span>] = &amp;numbers[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Slice: &#123;:?&#125;&quot;</span>, slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Option类型<br>Option类型在Rust中用于表示可能为空的值。它有两个可能的取值：Some(value)表示有值，None表示无值。Option类型可以帮助我们处理可能出现空值的情况。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">f64</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y != <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x / y)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Result类型<br>Result类型在Rust中用于处理可能发生错误的操作。它有两个可能的取值：Ok(value)表示操作成功，返回一个值，Err(error)表示操作失败，返回一个错误。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> y != <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(x / y)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">divide</span>(<span class="number">10.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, error),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数签名和函数返回值"><a href="#函数签名和函数返回值" class="headerlink" title="函数签名和函数返回值"></a>函数签名和函数返回值</h4><p>如上面的笔记，函数关键字fn，返回值后面不带任务符号</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(a: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="comment">// a 是参数，要求是一个32位无符号整数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="number">0</span> <span class="comment">// 0是一个32位无符号整数，后面不加;，表示返回a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><h4 id="break返回值"><a href="#break返回值" class="headerlink" title="break返回值"></a>break返回值</h4><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><h2 id="rust特性"><a href="#rust特性" class="headerlink" title="rust特性"></a>rust特性</h2><h3 id="默认不可变性"><a href="#默认不可变性" class="headerlink" title="默认不可变性"></a>默认不可变性</h3><p>rust所有的变量都默认不可变，在声明时添加mut可改变其不可变性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">12</span>;</span><br><span class="line">a = <span class="number">13</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="number">11</span>;</span><br><span class="line">b = <span class="number">45</span>; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>有个例外，rust支持const关键字，这就是一个常量，建议声明的常量名字全大写，由const声明的常量不支持mut</p><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>rust要求每一个值都有且只能有一个变量，从根源上避免了<a href="#####%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89">数据竞争</a>。</p><p>rust的所有权机制导致一旦一个变量被传递到了另一个作用范围，主要是从函数外部传递到内部，会导致外部的这个变量无效，在退出函数后，这个变量也不会重新有效（在函数内部被丢弃）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len); <span class="comment">// 这里，s1已经无效了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust支持传引用&amp;到函数，引用&amp;不会导致变量的所有权被转移，只是将值传递进函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123; <span class="comment">// 传进来一个可变的引用，支持修改外部的变量</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(s: &amp; <span class="type">String</span>) &#123; <span class="comment">// 不可变引用，不支持修改外部变量，只能使用这个值</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);  <span class="comment">// 不能通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust支持在函数内部声明一个变量，将其返回，外部就能够获得这个变量的所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust不支持返回在函数内部声明的变量的引用，因为引用只是值，变量本身会随着函数的退出而被丢弃，返回的引用就变成了无效的指针（dangling pointer）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s  <span class="comment">// 导致dangling pointer，无法通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，rust使用了严格的机制避免<a href="#####%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89">数据竞争</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题，可变引用会导致r1、r2的值不可靠</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h5 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h5><ol><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IEEE754数据转换示例</title>
      <link href="/2024/03/11/ieee754%E8%BD%AC%E6%8D%A2%E7%A4%BA%E4%BE%8B/"/>
      <url>/2024/03/11/ieee754%E8%BD%AC%E6%8D%A2%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="IEEE754数据转换示例"><a href="#IEEE754数据转换示例" class="headerlink" title="IEEE754数据转换示例"></a>IEEE754数据转换示例</h1><h2 id="IEEE754浮点数表示法"><a href="#IEEE754浮点数表示法" class="headerlink" title="IEEE754浮点数表示法"></a>IEEE754浮点数表示法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">| sign | exp | tail |</span><br><span class="line">+-------------------+</span><br><span class="line"></span><br><span class="line">sign: 符号位 0正数 1负数，单精度和双精度下均只有 1 bit</span><br><span class="line">exp: 指数，单精度下指数有 8 bits，双精度下有 11 bits</span><br><span class="line">tail: 尾数，单精度下有 23 bits，双精度下有 52 bits</span><br></pre></td></tr></table></figure><h2 id="浮点数转二进制"><a href="#浮点数转二进制" class="headerlink" title="浮点数转二进制"></a>浮点数转二进制</h2><p>示例数据：5.75</p><p>step 1: 转换成二进制 101.11</p><p>step 2: 将整数部分左右移，知道小数点前只有 1 个 1。 1.0111 右移 <strong>2</strong> 位，得到位数 0111 </p><p>step 3: 将这个移动的位数加上偏置值，单精度下，该偏置&#x3D;127，双精度下，该偏置量&#x3D;1023。指数exp &#x3D; 2 + 127 &#x3D; 129，得出指数二进制表示：1000 0001</p><p>step 4: 将符号位、指数、位数整合起来，尾数不足 23bits 后面添0 得到该浮点数的二进制表示： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------+-----------+------------------------------+</span><br><span class="line">| sign |    exp    |             tail             | </span><br><span class="line">+------+-----------+------------------------------+</span><br><span class="line">|   0  |  10000001 | 011 1000 0000 0000 0000 0000 |</span><br><span class="line">+------+-----------+------------------------------+ </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计网osi/ios七层模型设备和协议</title>
      <link href="/2024/03/11/%E8%AE%A1%E7%BD%91%E8%AE%BE%E5%A4%87%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/03/11/%E8%AE%A1%E7%BD%91%E8%AE%BE%E5%A4%87%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="计网osi-ios七层模型设备和协议"><a href="#计网osi-ios七层模型设备和协议" class="headerlink" title="计网osi&#x2F;ios七层模型设备和协议"></a>计网osi&#x2F;ios七层模型设备和协议</h1><ol><li>集线器（Hub）</li></ol><ul><li>将所有的主机通过集线器连接在一起，主机发出的数据会通过集线器发送到所有主机，接收到数据的主机根据实际情况选择接受或拒绝数据。</li><li>特点：将数据广播到连接在集线器的所有主机，不分割广播域&#x2F;网络</li><li>工作层次：物理层</li></ul><ol start="2"><li>交换机（Switch）</li></ol><ul><li>交换机维护一张mac地址表，字节流数据发送到交换机后，交换机会解析出源mac地址和目标mac地址，如果源mac地址不存在于维护的mac地址表，交换机会将源mac地址和对应的端口绑定起来，下次如果有数据要发送到记录在表的主机，会根据mac地址表解析出对应的端口，然后将字节流直接发到目标主机。</li><li>特点：将数据发送到指定端口，会分割广播域，不分割网络</li><li>工作层次：数据链路层</li></ul><p>功能上的差异：交换机工作在数据链路层，能够识别数据包中的MAC地址信息。它根据MAC地址将数据准确地传输给目标端口，从而减少了不必要的数据传输，提高了网络的效率和安全性。<br>工作层次：OSI模型的第2层（数据链路层）。</p><ol start="3"><li>路由器（Router）</li></ol><p>功能上的差异：路由器工作在网络层，主要负责不同网络之间的数据传输和路由选择。它根据IP地址和路由协议，确定数据包的最佳路径，并能够处理不同网络协议的数据包，如IP、IPX等。<br>工作层次：OSI模型的第3层（网络层）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/07/ostep%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/07/ostep%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ostep读书小记"><a href="#ostep读书小记" class="headerlink" title="ostep读书小记"></a>ostep读书小记</h1><h2 id="Chapter-1-进程"><a href="#Chapter-1-进程" class="headerlink" title="Chapter 1 进程"></a>Chapter 1 进程</h2><ol><li><p>进程的定义：运行着的程序<br>操作系统将存放在磁盘的程序加载到内存，将处理机资源分配给这些字节数据，程序就运行起来了。</p></li><li><p>CPU分时<br>操作系统会营造一种有着用不完的cpu的假象，使用的方法就是<strong>CPU分时</strong>技术。<br>什么是CPU分时技术？</p></li></ol><p>实现CPU分时技术的前提？</p><ul><li>需要cpu支持内核态和用户态机制。<blockquote><p>如【上下文切换技术】，该技术支持操作系统停下一个程序，去跑起另一个程序。需要保存要停止的程序的上下文内容，然后切换到另一个程序。</p></blockquote></li><li>需要操作系统支持一些调度算法。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/03/index/"/>
      <url>/2024/03/03/index/</url>
      
        <content type="html"><![CDATA[<style>@keyframes gradientBG{0%{background-position: 0% 50%;}50%{background-position: 100% 50%;}100% {background-position: 0% 50%;}}#rightside{display:none;}</style><blockquote><p>这个页面是用来测试渐变背景的效果，以及不同透明度的效果。如果你有能力可以直接看 css 样式。否则请返回<a href="https://www.antmoe.com/posts/7198453/index.html#%E9%99%84%E5%BD%95">Hexo 博客之 butterfly 主题优化更换背景</a>复制代码。<br>阅读体验及个标签样式请自己进行调整。</p></blockquote><h2 id="透明度调节"><a href="#透明度调节" class="headerlink" title="透明度调节"></a>透明度调节</h2><center style='margin-bottom:20px' id = 'opt'><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0">透明度0</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0.1">透明度0.1</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0.2">透明度0.2</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0.3">透明度0.3</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0.4">透明度0.4</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0.5">透明度0.5</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0.6">透明度0.6</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0.7">透明度0.7</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0.8">透明度0.8</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="0.9">透明度0.9</a><a style="color: #FFF;margin-bottom: 10px;"  style="color: #FFF;" href="#" class="button button-primary button-rounded button-small" data-opacity="1">透明度1</a></center><h2 id="背景调节"><a href="#背景调节" class="headerlink" title="背景调节"></a>背景调节</h2><div id='demo_style' style='text-align:center;margin:0 auto;'><h3 id="渐变类"><a href="#渐变类" class="headerlink" title="渐变类"></a>渐变类</h3><div data-type="photo" class='bg_test' style="display:inline-block;width: 200px;height:200px;background: url(&quot;https://ae01.alicdn.com/kf/H5662031fbf344418aa2c8bf74c68826eV.png&quot;),linear-gradient(45deg, #6dd0f2 15%, #f59abe 85%);text-align: center;line-height: 200px;margin-bottom:5px;cursor: pointer;">粉蓝色有图片</div><div data-type="photo" class='bg_test' style="display:inline-block;width: 200px;height:200px;background: linear-gradient(45deg, #6dd0f2 15%, #f59abe 85%);text-align: center;line-height: 200px;cursor: pointer;">粉蓝色无图片</div><div data-type="photo" class='bg_test' style="display:inline-block;width: 200px;height:200px;background: linear-gradient(102.7deg,#fddaff 8.2%,#dfadfc 19.6%,#adcdfc 36.8%,#adfcf4 73.2%,#caf8d0 90.9%);text-align: center;line-height: 200px;cursor: pointer;">美美哒渐变</div><div data-type="color" class='bg_test' style="display:inline-block;width: 200px;height:200px; background: linear-gradient(90deg,rgba(247,149,51,.1) 0,rgba(243,112,85,.1) 15%,rgba(239,78,123,.1) 30%,rgba(161,102,171,.1) 44%,rgba(80,115,184,.1) 58%,rgba(16,152,173,.1) 72%,rgba(7,179,155,.1) 86%,rgba(109,186,130,.1) 100%);text-align: center;line-height: 200px;cursor: pointer;">博主同款</div><div data-type="photo" class='bg_test' style="display:inline-block;width: 200px;height:200px; background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    background-size: 400% 400%;animation: gradientBG 15s ease infinite;text-align: center;line-height: 200px;cursor: pointer;">动态渐变</div><div data-type="photo" class='bg_test' style="display:inline-block;width: 200px;height:200px; background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%);text-align: center;line-height: 200px;cursor: pointer;">紫蓝色渐变</div><h3 id="渐变加图片类"><a href="#渐变加图片类" class="headerlink" title="渐变加图片类"></a>渐变加图片类</h3><div data-type="photo" class='bg_test' style="display:inline-block;width: 200px;height:200px; background: linear-gradient(60deg, rgba(255, 165, 150, 0.5) 5%, rgba(0, 228, 255, 0.35)), url(https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png),url(https://ae01.alicdn.com/kf/H21b5f6b8496141a1979a33666e1074d9x.jpg)0% 0% / cover;text-align: center;line-height: 200px;cursor: pointer; background-size: cover;">紫蓝色渐变</div><h3 id="图片类"><a href="#图片类" class="headerlink" title="图片类"></a>图片类</h3><div data-type="photo" class='bg_test' style="display:inline-block;width: 200px;height:200px; background: url(https://api.abcyun.co/api/tool/bing/token/5d8f31cf6a8ab);text-align: center;line-height: 200px;cursor: pointer; background-size: cover;">必应壁纸</div><div data-type="photo" class='bg_test' style="display:inline-block;width: 200px;height:200px; background: url(https://api.abcyun.co/api/others/randacgimage/token/5d8f31cf6a8ab);text-align: center;line-height: 200px;cursor: pointer; background-size: cover;">随机二次元图</div><div data-type="photo" class='bg_test' style="display:inline-block;width: 200px;height:200px; background: url(https://api.abcyun.co/api/others/randacgblogbg/token/5d8f31cf6a8ab);text-align: center;line-height: 200px;cursor: pointer; background-size: cover;">随机二次元背景图</div></div><h2 id="测试文章"><a href="#测试文章" class="headerlink" title="测试文章"></a>测试文章</h2><h3 id="春"><a href="#春" class="headerlink" title="春"></a>春</h3><p>盼望着，盼望着，东风来了，春天的脚步近了。</p><p>一切都像刚睡醒的样子，欣欣然张开了眼。山朗润起来了，水长起来了，太阳的脸红起来了。</p><p>小草偷偷地从土里钻出来，嫩嫩的，绿绿的。园子里，田野里，瞧去，一大片一大片满是的。坐着，躺着，打两个滚，踢几脚球，赛几趟跑，捉几回迷藏。风轻悄悄的，草绵软软的。</p><p>桃树、杏树、梨树，你不让我，我不让你，都开满了花赶趟儿。红的像火，粉的像霞，白的像雪。花里带着甜味，闭了眼，树上仿佛已经满是桃儿、杏儿、梨儿。花下成千成百的蜜蜂嗡嗡地闹着，大小的蝴蝶飞来飞去。野花遍地是：杂样儿，有名字的，没名字的，散在花丛里，像眼睛，像星星，还眨呀眨的。</p><p>“吹面不寒杨柳风”，不错的，像母亲的手抚摸着你。风里带来些新翻的泥土的气息，混着青草味，还有各种花的香，都在微微润湿的空气里酝酿。鸟儿将窠巢安在繁花嫩叶当中，高兴起来了，呼朋引伴地卖弄清脆的喉咙，唱出宛转的曲子，与轻风流水应和着。牛背上牧童的短笛，这时候也成天在嘹亮地响。</p><p>雨是最寻常的，一下就是三两天。可别恼。看，像牛毛，像花针，像细丝，密密地斜织着，人家屋顶上全笼着一层薄烟。树叶子却绿得发亮，小草也青得逼你的眼。傍晚时候，上灯了，一点点黄晕的光，烘托出一片这安静而和平的夜。乡下去，小路上，石桥边，撑起伞慢慢走着的人;还有地里工作的农夫，披着蓑，戴着笠的。他们的草屋，稀稀疏疏的在雨里静默着。</p><p>天上风筝渐渐多了，地上孩子也多了。城里乡下，家家户户，老老小小，他们也赶趟儿似的，一个个都出来了。舒活舒活筋骨，抖擞抖擞精神，各做各的一份事去，“一年之计在于春”;刚起头儿，有的是工夫，有的是希望。</p><p>春天像刚落地的娃娃，从头到脚都是新的，它生长着。</p><p>春天像小姑娘，花枝招展的，笑着，走着。</p><p>春天像健壮的青年，有铁一般的胳膊和腰脚，他领着我们上前去。</p><ol><li>有序列表</li><li>有序</li><li>有</li></ol><ul><li>无需列表</li><li>测试</li></ul><div class="note default icon flat"><p>default</p></div><div class="note primary icon flat"><p>primary</p></div><div class="note success icon flat"><p>success</p></div><div class="note info icon flat"><p>info</p></div><div class="note warning icon flat"><p>warning</p></div><div class="note danger icon flat"><p>danger</p></div><div class="note primary no-icon flat"><h4 id="Primary-HeaderWelcome-to-Hexo"><a href="#Primary-HeaderWelcome-to-Hexo" class="headerlink" title="Primary HeaderWelcome to Hexo!"></a>Primary Header<strong>Welcome</strong> to <a href="https://hexo.io/">Hexo!</a></h4></div><script>var article_container=document.getElementById("demo_style"),opt=document.getElementById("opt");article_container.addEventListener("click",function(e){var t=e.target;"DIV"===t.nodeName&&"bg_test"===t.className&&(web_bg.style.background=t.style.background,web_bg.style.animation=t.style.animation),Cookies.set("bg",t.style.background,{expires:1}),Cookies.set("animation",t.style.animation,{expires:1}),Cookies.set("type",t.getAttribute("data-type"),{expires:1})}),opt.addEventListener("click",function(e){var t=e.target;if("A"===t.nodeName){var a=t.getAttribute("data-opacity");if(a){Cookies.set("opacity",a,{expires:1});var n="--light_bg_color: rgb(255, 255, 255,"+a+");",i="--dark_bg_color: rgba(18,18,18,"+a+");";document.getElementById("content-inner").setAttribute("style",n+i)}}e.preventDefault()});</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/03/custom/config/index/"/>
      <url>/2024/03/03/custom/config/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/03/custom/css/custom/"/>
      <url>/2024/03/03/custom/css/custom/</url>
      
        <content type="html"><![CDATA[body {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur),        default;}a,img {    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur),        default;}/* 页脚footer *//* 渐变色滚动动画 */@-webkit-keyframes Gradient {    0% {        background-position: 0 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0 50%;    }}@keyframes Gradient {    0% {        background-position: 0 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0 50%;    }}#footer {    background: linear-gradient(-45deg, #ee7752, #ce3e75, #23a6d5, #23d5ab);    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite;    -o-user-select: none;    -ms-user-select: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    border-top-left-radius: 10px;    border-top-right-radius: 10px;}#footer:before {    background-color: rgba(0, 0, 0, 0);}/* 滚动条 */::-webkit-scrollbar {    width: 8px;    height: 8px;}::-webkit-scrollbar-track {    background-color: rgba(73, 177, 245, 0.2);    border-radius: 2em;}::-webkit-scrollbar-thumb {    background-color: #49b1f5;    background-image: -webkit-linear-gradient(45deg,            rgba(255, 255, 255, 0.4) 25%,            transparent 25%,            transparent 50%,            rgba(255, 255, 255, 0.4) 50%,            rgba(255, 255, 255, 0.4) 75%,            transparent 75%,            transparent);    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #49b1f5;}/* 分类卡片 */#aside_content.card-archivesul.card-archive-list> .card-archive-list-itemaspan:first-child,#aside_content.card-categoriesul.card-category-list> .card-category-list-itemaspan:first-child {    width: auto;    min-width: 50%;}#aside_content .card-widget,#recent-posts>.recent-post-item,.layout_page>div:first-child:not(.recent-posts),.layout_post>#page,.layout_post>#post,.read-mode .layout_post>#post {    background: var(--light_bg_color)}[data-theme=dark] #nav,[data-theme=dark] .layout_page>div:first-child:not(.recent-posts),[data-theme=dark] .layout_post>#post {    background-color: var(--dark_bg_color)}]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/02/18/MySQL45%E8%AE%B2%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/02/18/MySQL45%E8%AE%B2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql45讲学习笔记"><a href="#mysql45讲学习笔记" class="headerlink" title="mysql45讲学习笔记"></a>mysql45讲学习笔记</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="acid四大特性"><a href="#acid四大特性" class="headerlink" title="acid四大特性"></a>acid四大特性</h3><ul><li>Atomic原子性</li><li>Consistent一致性</li><li>Isolated隔离性</li><li>Durability持久性</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>串行化</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>读写锁</li><li>乐观&#x2F;悲观锁</li><li>意向锁</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="MySQL分库分表"><a href="#MySQL分库分表" class="headerlink" title="MySQL分库分表"></a>MySQL分库分表</h2><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/02/08/%E7%A8%8B%E5%BA%8F%E6%AE%B5%E8%B5%84%E6%96%99/"/>
      <url>/2024/02/08/%E7%A8%8B%E5%BA%8F%E6%AE%B5%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<p>主要的程序段：</p><ul><li>.init：保存 bootloader 的代码和数据。这个特殊的段在CMakefiles.txt中定义。所有其余的程序段都是真正的 ChCore 内核。</li><li>.text：内核程序代码，由一条条的机器指令组成。</li><li>.data：保存初始化的全局变量或静态变量数据。定义在函数内部的局部非静态变量不在该段中存储。</li><li>.rodata：保存只读数据，包括一些不可修改的常量数据，例如全局常量、char *str &#x3D; “apple”中的字符串常量等。然而，如果使用char str2[] &#x3D; “apple”，那么此时该字符串是动态地存在栈上的。</li><li>.bss：记录未初始化的全局或静态变量，例如int a。由于在运行期间未初始化的全局变量被初始化为 0，因此链接器只记录地址和大小，而不是占用实际空间。<br>除上面列出的部分外，其他大多数段都包含调试信息，通常包含在可执行文件中，而不是加载到内存中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">  print();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">test:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">0000000000001000 &lt;_init&gt;:</span><br><span class="line">    1000:       f3 0f 1e fa             endbr64</span><br><span class="line">    1004:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">    1008:       48 8b 05 d9 2f 00 00    mov    0x2fd9(%rip),%rax        # 3fe8 &lt;__gmon_start__@Base&gt;</span><br><span class="line">    100f:       48 85 c0                test   %rax,%rax</span><br><span class="line">    1012:       74 02                   je     1016 &lt;_init+0x16&gt;</span><br><span class="line">    1014:       ff d0                   call   *%rax</span><br><span class="line">    1016:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">    101a:       c3                      ret</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">0000000000001020 &lt;.plt&gt;:</span><br><span class="line">    1020:       ff 35 a2 2f 00 00       push   0x2fa2(%rip)        # 3fc8 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line">    1026:       f2 ff 25 a3 2f 00 00    bnd jmp *0x2fa3(%rip)        # 3fd0 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br><span class="line">    102d:       0f 1f 00                nopl   (%rax)</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt.got:</span><br><span class="line"></span><br><span class="line">0000000000001030 &lt;__cxa_finalize@plt&gt;:</span><br><span class="line">    1030:       f3 0f 1e fa             endbr64</span><br><span class="line">    1034:       f2 ff 25 bd 2f 00 00    bnd jmp *0x2fbd(%rip)        # 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br><span class="line">    103b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000001040 &lt;_start&gt;:</span><br><span class="line">    1040:       f3 0f 1e fa             endbr64</span><br><span class="line">    1044:       31 ed                   xor    %ebp,%ebp</span><br><span class="line">    1046:       49 89 d1                mov    %rdx,%r9</span><br><span class="line">    1049:       5e                      pop    %rsi</span><br><span class="line">    104a:       48 89 e2                mov    %rsp,%rdx</span><br><span class="line">    104d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp</span><br><span class="line">    1051:       50                      push   %rax</span><br><span class="line">    1052:       54                      push   %rsp</span><br><span class="line">    1053:       45 31 c0                xor    %r8d,%r8d</span><br><span class="line">    1056:       31 c9                   xor    %ecx,%ecx</span><br><span class="line">    1058:       48 8d 3d ca 00 00 00    lea    0xca(%rip),%rdi        # 1129 &lt;main&gt;</span><br><span class="line">    105f:       ff 15 73 2f 00 00       call   *0x2f73(%rip)        # 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt;</span><br><span class="line">    1065:       f4                      hlt</span><br><span class="line">    1066:       66 2e 0f 1f 84 00 00    cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">    106d:       00 00 00</span><br><span class="line"></span><br><span class="line">0000000000001070 &lt;deregister_tm_clones&gt;:</span><br><span class="line">    1070:       48 8d 3d 99 2f 00 00    lea    0x2f99(%rip),%rdi        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    1077:       48 8d 05 92 2f 00 00    lea    0x2f92(%rip),%rax        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    107e:       48 39 f8                cmp    %rdi,%rax</span><br><span class="line">    1081:       74 15                   je     1098 &lt;deregister_tm_clones+0x28&gt;</span><br><span class="line">    1083:       48 8b 05 56 2f 00 00    mov    0x2f56(%rip),%rax        # 3fe0 &lt;_ITM_deregisterTMCloneTable@Base&gt;</span><br><span class="line">    108a:       48 85 c0                test   %rax,%rax</span><br><span class="line">    108d:       74 09                   je     1098 &lt;deregister_tm_clones+0x28&gt;</span><br><span class="line">    108f:       ff e0                   jmp    *%rax</span><br><span class="line">    1091:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)</span><br><span class="line">    1098:       c3                      ret</span><br><span class="line">    1099:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">00000000000010a0 &lt;register_tm_clones&gt;:</span><br><span class="line">    10a0:       48 8d 3d 69 2f 00 00    lea    0x2f69(%rip),%rdi        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    10a7:       48 8d 35 62 2f 00 00    lea    0x2f62(%rip),%rsi        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    10ae:       48 29 fe                sub    %rdi,%rsi</span><br><span class="line">    10b1:       48 89 f0                mov    %rsi,%rax</span><br><span class="line">    10b4:       48 c1 ee 3f             shr    $0x3f,%rsi</span><br><span class="line">    10b8:       48 c1 f8 03             sar    $0x3,%rax</span><br><span class="line">    10bc:       48 01 c6                add    %rax,%rsi</span><br><span class="line">    10bf:       48 d1 fe                sar    %rsi</span><br><span class="line">    10c2:       74 14                   je     10d8 &lt;register_tm_clones+0x38&gt;</span><br><span class="line">    10c4:       48 8b 05 25 2f 00 00    mov    0x2f25(%rip),%rax        # 3ff0 &lt;_ITM_registerTMCloneTable@Base&gt;</span><br><span class="line">    10cb:       48 85 c0                test   %rax,%rax</span><br><span class="line">    10ce:       74 08                   je     10d8 &lt;register_tm_clones+0x38&gt;</span><br><span class="line">    10d0:       ff e0                   jmp    *%rax</span><br><span class="line">    10d2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)</span><br><span class="line">    10d8:       c3                      ret</span><br><span class="line">    10d9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">00000000000010e0 &lt;__do_global_dtors_aux&gt;:</span><br><span class="line">    10e0:       f3 0f 1e fa             endbr64</span><br><span class="line">    10e4:       80 3d 25 2f 00 00 00    cmpb   $0x0,0x2f25(%rip)        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    10eb:       75 2b                   jne    1118 &lt;__do_global_dtors_aux+0x38&gt;</span><br><span class="line">    10ed:       55                      push   %rbp</span><br><span class="line">    10ee:       48 83 3d 02 2f 00 00    cmpq   $0x0,0x2f02(%rip)        # 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br><span class="line">    10f5:       00</span><br><span class="line">    10f6:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    10f9:       74 0c                   je     1107 &lt;__do_global_dtors_aux+0x27&gt;</span><br><span class="line">    10fb:       48 8b 3d 06 2f 00 00    mov    0x2f06(%rip),%rdi        # 4008 &lt;__dso_handle&gt;</span><br><span class="line">    1102:       e8 29 ff ff ff          call   1030 &lt;__cxa_finalize@plt&gt;</span><br><span class="line">    1107:       e8 64 ff ff ff          call   1070 &lt;deregister_tm_clones&gt;</span><br><span class="line">    110c:       c6 05 fd 2e 00 00 01    movb   $0x1,0x2efd(%rip)        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    1113:       5d                      pop    %rbp</span><br><span class="line">    1114:       c3                      ret</span><br><span class="line">    1115:       0f 1f 00                nopl   (%rax)</span><br><span class="line">    1118:       c3                      ret</span><br><span class="line">    1119:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000001120 &lt;frame_dummy&gt;:</span><br><span class="line">    1120:       f3 0f 1e fa             endbr64</span><br><span class="line">    1124:       e9 77 ff ff ff          jmp    10a0 &lt;register_tm_clones&gt;</span><br><span class="line"></span><br><span class="line">0000000000001129 &lt;main&gt;:</span><br><span class="line">    1129:       f3 0f 1e fa             endbr64</span><br><span class="line">    112d:       55                      push   %rbp</span><br><span class="line">    112e:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1131:       48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">    1135:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)</span><br><span class="line">    113c:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    1141:       e8 07 00 00 00          call   114d &lt;print&gt;</span><br><span class="line">    1146:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">    114b:       c9                      leave</span><br><span class="line">    114c:       c3                      ret</span><br><span class="line"></span><br><span class="line">000000000000114d &lt;print&gt;:</span><br><span class="line">    114d:       f3 0f 1e fa             endbr64</span><br><span class="line">    1151:       55                      push   %rbp</span><br><span class="line">    1152:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1155:       90                      nop</span><br><span class="line">    1156:       5d                      pop    %rbp</span><br><span class="line">    1157:       c3                      ret</span><br><span class="line"></span><br><span class="line">Disassembly of section .fini:</span><br><span class="line"></span><br><span class="line">0000000000001158 &lt;_fini&gt;:</span><br><span class="line">    1158:       f3 0f 1e fa             endbr64</span><br><span class="line">    115c:       48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">    1160:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">    1164:       c3                      ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/02/08/algo/"/>
      <url>/2024/02/08/algo/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法-考研难点总结"><a href="#数据结构与算法-考研难点总结" class="headerlink" title="数据结构与算法 考研难点总结"></a>数据结构与算法 考研难点总结</h1><h2 id="算法的稳定性"><a href="#算法的稳定性" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h2><p>相等的元素，排序前后相对位置如果变动，该算法就不稳定；</p><blockquote><p>如5 1 2 5 0，使用选择排序后是 0 1 2 5 5最后一个5原本在前一个5的前面，排序完后到了后面，相对位置发生了变化，<strong>选择排序</strong>就不稳定</p></blockquote><h2 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h2><h3 id="bf算法（引子）"><a href="#bf算法（引子）" class="headerlink" title="bf算法（引子）"></a>bf算法（引子）</h3><p>时间复杂度：O(mn)<br>逻辑：模式串（匹配的内容）与主串逐个匹配，一个对不上，指向主串的指针前进一次，最坏情况下匹配m*n次</p><h3 id="kmp算法（难点）"><a href="#kmp算法（难点）" class="headerlink" title="kmp算法（难点）"></a>kmp算法（难点）</h3><p>时间复杂度：O(m+n)<br>逻辑：</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>时间复杂度：O(n^2)<br>逻辑：遍历整个数组，逆序则交换，达成局部有序，完成一轮再重新遍历，将局部有序变成整体有序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><p>时间复杂度：O(n^2)，如果刚好数组从大到小，遍历n次，每次对比n次<br>逻辑：每次从原数组中找出最小的放到未排序部分的最左边（自然顺序，也叫从小到大）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = arr[i];</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 找出最小值</span></span><br><span class="line">            <span class="keyword">if</span> (min &gt; arr[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                min = arr[j];   <span class="comment">// 更新最小值</span></span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新已排序部分</span></span><br><span class="line">        <span class="keyword">if</span> (index != i) </span><br><span class="line">        &#123;</span><br><span class="line">            arr[index] = arr[i];</span><br><span class="line">            arr[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><p>时间复杂度：O(n^2)<br>实现逻辑：从未排序部分拿出第一个元素，与已排序部分的每一个元素比较，直到找到大于它的，将他插入到其后。<br>不会修改相等元素的相对位置，属于稳定算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h3><p>时间复杂度：<br>实现思想：选中哨兵元素，遍历数组，右边大于哨兵，向左遍历，左边小于哨兵，向右遍历，否则交换两边的元素，最终哨兵左右与哨兵元素保持 <strong>左 &lt; 哨兵 &lt; 右</strong> 的关系</p><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><h3 id="6-桶排序"><a href="#6-桶排序" class="headerlink" title="6. 桶排序"></a>6. 桶排序</h3><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><h3 id="8-希尔排序"><a href="#8-希尔排序" class="headerlink" title="8. 希尔排序"></a>8. 希尔排序</h3><h3 id="9-计数排序"><a href="#9-计数排序" class="headerlink" title="9. 计数排序"></a>9. 计数排序</h3><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java开发笔记</title>
      <link href="/2024/01/25/java%E6%80%BB%E7%BB%93/"/>
      <url>/2024/01/25/java%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="java开发笔记"><a href="#java开发笔记" class="headerlink" title="java开发笔记"></a>java开发笔记</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>list自带排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MyObject&gt; list = ...;</span><br><span class="line">list.sort((o1, o2) -&gt; o2.getXXX().compareTo(o1.getXXX()));   <span class="comment">// 倒序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * x.compareTo(y):</span></span><br><span class="line"><span class="comment"> * 返回值：</span></span><br><span class="line"><span class="comment"> * 1. &gt; 0, x &gt; y; </span></span><br><span class="line"><span class="comment"> * 2. &lt; 0, x &lt; y;</span></span><br><span class="line"><span class="comment"> * 3. = 0, x = y</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>自排序，无返回值</li><li>如果是对象类型的元素，需要重写Comporator比较器</li></ul><h2 id="分割字符串，构造不大于指定大小的字串"><a href="#分割字符串，构造不大于指定大小的字串" class="headerlink" title="分割字符串，构造不大于指定大小的字串"></a>分割字符串，构造不大于指定大小的字串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">splitStr</span><span class="params">(String input, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    List&lt;String&gt; resultStrList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    String[] lines = input.split(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sb.length() + line.length() + <span class="number">1</span> &gt; length) &#123; <span class="comment">// 超过目标长度</span></span><br><span class="line">            resultStrList.add(sb.toString()); <span class="comment">// 添加当前字串到结果列表</span></span><br><span class="line">            sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 重置 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(line).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加最后一个字串</span></span><br><span class="line">    <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultStrList.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStrList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/22/custom/js/script/"/>
      <url>/2024/01/22/custom/js/script/</url>
      
        <content type="html"><![CDATA[var mobile_sidebar_menus = document.getElementById("mobile-sidebar-menus");var menus_item_child = mobile_sidebar_menus.getElementsByClassName(    "menus_item_child");var menus_expand = mobile_sidebar_menus.getElementsByClassName("menus-expand");for (var i = 0; i < menus_item_child.length; i++) {    menus_item_child[i].style.display = "none";    menus_expand[i].className += " menus-closed";}// 分类卡片var card_category_list = document.getElementsByClassName(    "card-category-list child");var item = document.getElementsByClassName("card-category-list-item");function toggle(t) {    var display = t.parentElement.nextSibling.style.display;    if (display == "none") {        t.parentElement.nextSibling.style.display = "block";        t.parentElement.nextSibling.style.height = "100%";        t.className = t.className.replace("fa-chevron-up", "fa-chevron-down");    } else {        t.parentElement.nextSibling.style.display = "none";        t.className = t.className.replace("fa-chevron-down", "fa-chevron-up");    }}for (var i = 0; i < card_category_list.length; i++) {    card_category_list[i].style.display = "none";    card_category_list[i].style.transition = "all 1s";    card_category_list[i].previousSibling.innerHTML +=        '<i class="fa fa-chevron-up menus-expand  menus-closed" aria-hidden="true" style="margin-left:20px;" onclick="toggle(this)"></i>';}// 获取标签// 全局背景divvar web_bg = document.getElementById("web_bg");// 公共父级var content_inner = document.getElementById("content-inner");// 获取Cookies// 透明度var opacity = Cookies.get("opacity");// 背景var bg = Cookies.get("bg");// 动画var animation = Cookies.get("animation");// 背景类型var type = Cookies.get("type");// 声明遍历 用于记录当前color// 设置背景if (bg) {  web_bg.style.background = bg;  web_bg.setAttribute("data-type", type);  if (animation) {    web_bg.style.animation = animation;  }}function setColor(opacity) {  // style="--light_bg_color: rgb(255, 255, 255,.3);--dark_bg_color: rgba(18,18,18,.2);"  var light_bg_color = "--light_bg_color: rgb(255, 255, 255," + opacity + ");";  var dark_bg_color = "--dark_bg_color: rgba(18,18,18," + opacity + ");";  content_inner.setAttribute("style", light_bg_color + dark_bg_color);}setColor(opacity);]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csapp阅读笔记</title>
      <link href="/2023/12/28/csapp/"/>
      <url>/2023/12/28/csapp/</url>
      
        <content type="html"><![CDATA[<h1 id="csapp阅读笔记"><a href="#csapp阅读笔记" class="headerlink" title="csapp阅读笔记"></a>csapp阅读笔记</h1><h2 id="ch1-计算机系统漫游"><a href="#ch1-计算机系统漫游" class="headerlink" title="ch1 计算机系统漫游"></a>ch1 计算机系统漫游</h2><ol><li>程序在计算机中以‘比特’的形式存储；</li><li>c程序到可执行程序：.c(源文件) –&gt; .i(预编译后得到的文件) –&gt; .s(编译后得到的文件) –&gt; .o(汇编后得到的文件) –&gt; .out(可执行文件)</li><li>了解编译系统如何工作有什么好处？</li></ol><ul><li>优化程序性能：switch和if-else如何取舍？while与for如何选择？指针与索引访问数组，哪一个效率更高？</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>intel x86汇编语法</title>
      <link href="/2023/12/27/intel%20x86%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/12/27/intel%20x86%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="intel-x86基本汇编语法"><a href="#intel-x86基本汇编语法" class="headerlink" title="intel x86基本汇编语法"></a>intel x86基本汇编语法</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-保护模式和实模式"><a href="#1-1-保护模式和实模式" class="headerlink" title="1.1 保护模式和实模式"></a>1.1 保护模式和实模式</h3><h3 id="1-2-段"><a href="#1-2-段" class="headerlink" title="1.2 段"></a>1.2 段</h3><h4 id="1-2-1-段的概念"><a href="#1-2-1-段的概念" class="headerlink" title="1.2.1 段的概念"></a>1.2.1 段的概念</h4><h4 id="1-2-2-为什么分段"><a href="#1-2-2-为什么分段" class="headerlink" title="1.2.2 为什么分段"></a>1.2.2 为什么分段</h4><h4 id="1-2-3-使用intel汇编语法访问内存段"><a href="#1-2-3-使用intel汇编语法访问内存段" class="headerlink" title="1.2.3 使用intel汇编语法访问内存段"></a>1.2.3 使用intel汇编语法访问内存段</h4><h3 id="1-3-偏移"><a href="#1-3-偏移" class="headerlink" title="1.3 偏移"></a>1.3 偏移</h3><h4 id="1-3-1-偏移的概念"><a href="#1-3-1-偏移的概念" class="headerlink" title="1.3.1 偏移的概念"></a>1.3.1 偏移的概念</h4><h4 id="1-3-1-段内寻址"><a href="#1-3-1-段内寻址" class="headerlink" title="1.3.1 段内寻址"></a>1.3.1 段内寻址</h4><h3 id="1-4-中断"><a href="#1-4-中断" class="headerlink" title="1.4 中断"></a>1.4 中断</h3><h4 id="1-4-1-中断的概念"><a href="#1-4-1-中断的概念" class="headerlink" title="1.4.1 中断的概念"></a>1.4.1 中断的概念</h4><h4 id="1-4-2-什么时候触发中断"><a href="#1-4-2-什么时候触发中断" class="headerlink" title="1.4.2 什么时候触发中断"></a>1.4.2 什么时候触发中断</h4><h4 id="1-4-3-中断指令"><a href="#1-4-3-中断指令" class="headerlink" title="1.4.3 中断指令"></a>1.4.3 中断指令</h4><h3 id="1-5-寄存器寻址"><a href="#1-5-寄存器寻址" class="headerlink" title="1.5 寄存器寻址"></a>1.5 寄存器寻址</h3><h3 id="1-6-内存寻址"><a href="#1-6-内存寻址" class="headerlink" title="1.6 内存寻址"></a>1.6 内存寻址</h3><h3 id="1-7-io"><a href="#1-7-io" class="headerlink" title="1.7 io"></a>1.7 io</h3><h2 id="二、基本语法和代码落地"><a href="#二、基本语法和代码落地" class="headerlink" title="二、基本语法和代码落地"></a>二、基本语法和代码落地</h2><h2 id="三、对比at-t汇编语法"><a href="#三、对比at-t汇编语法" class="headerlink" title="三、对比at&amp;t汇编语法"></a>三、对比at&amp;t汇编语法</h2><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>http协议</title>
      <link href="/2023/12/22/http%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/12/22/http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念特点"><a href="#一、概念特点" class="headerlink" title="一、概念特点"></a>一、概念特点</h2><p>无状态协议，上一条http请求与下一条http请求没有任何联系，如果上一条是登录请求，下一条如果没有附带上一条的结果（也就是状态），下一条依旧是未登录状态，由此产生cookie技术</p><h2 id="二、表现"><a href="#二、表现" class="headerlink" title="二、表现"></a>二、表现</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://主机地址[:端口][绝对路径]</span><br></pre></td></tr></table></figure><h2 id="三、基本结构"><a href="#三、基本结构" class="headerlink" title="三、基本结构"></a>三、基本结构</h2><h3 id="3-1-请求"><a href="#3-1-请求" class="headerlink" title="3.1 请求"></a>3.1 请求</h3><blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------------------------+</span><br><span class="line">|      method       |    uri    |    version    |    CRLF    |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                           header                           |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                                                            |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                            data                            |</span><br><span class="line">+------------------------------------------------------------+</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>method:</p><ul><li>GET请求获取URI所标识的资源 </li><li>POST在URI所标识的资源后增加新的数据 </li><li>HEAD请求获取由URI所标识的资源的响应消息报头 </li><li>PUT请求服务器存储或修改一个资源，并用URI作为其标识 </li><li>DELETE请求服务器删除URI所标识的资源 </li><li>TRACE请求服务器回送收到的请求信息，主要用于测试或诊断 </li><li>CONNECT保留将来使用 </li><li>OPTIONS请求查询服务器的性能，或者查询与资源相关的选项和需求</li></ul></blockquote><blockquote><p>HTTP请求头<br>消息报头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息<br>HTTP请求正文<br>只有在发送POST请求时才会有请求正文，GET方法并没有请求正文。</p></blockquote><h3 id="3-2-响应"><a href="#3-2-响应" class="headerlink" title="3.2 响应"></a>3.2 响应</h3><blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------------------------+</span><br><span class="line">|      version      |    code    |     text     |    CRLF    |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                           header                           |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                                                            |</span><br><span class="line">+------------------------------------------------------------+</span><br><span class="line">|                            data                            |</span><br><span class="line">+------------------------------------------------------------+</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、端口约定"><a href="#四、端口约定" class="headerlink" title="四、端口约定"></a>四、端口约定</h2><p>应用层协议通常都制定好了端口号，如http协议指定80端口，https默认端口443，telnet默认端口23，dns默认端口53，snmp默认161。</p><p>传输层协议，如tcp、udp，都是需要端口，但是可以随意指定，比如搭建一个tcp服务器，应用层使用telnet接收消息，对应的tcp端口就可以设置为23，再启动一个http服务器，对应另一个tcp服务器端口可以设置为80等</p><h2 id="五、http-https在应用层的作用"><a href="#五、http-https在应用层的作用" class="headerlink" title="五、http&#x2F;https在应用层的作用"></a>五、http&#x2F;https在应用层的作用</h2><p>负责发起网页请求，将用户需要的信息返回回来</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络层ip协议</title>
      <link href="/2023/12/22/%E7%BD%91%E7%BB%9C%E5%B1%82ip%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/12/22/%E7%BD%91%E7%BB%9C%E5%B1%82ip%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层IP协议"><a href="#网络层IP协议" class="headerlink" title="网络层IP协议"></a>网络层IP协议</h1><h2 id="IP协议结构"><a href="#IP协议结构" class="headerlink" title="IP协议结构"></a>IP协议结构</h2><p><img src="/blogs/sfzoz81v.bmp" alt="ip协议结构图"><br>字段详细说明</p><ol><li>Version（版本号）：IP 协议版本号。目前只有两个版本：IPv4 和 IPv6</li><li>HeaderLength（IP 协议头部长度）：IP 协议头部的长度，单位字节（32bit）需要这个值是因为任选字段的长度是可变的，这个字段占 4bit（最多能表示 15 个 32bit 的的字，即 4*15&#x3D;60 个字节的首部长度），因此 IP 头部最多有 60 字节长度。正常的长度是 20 字节；如果有额外的 IP 的 options 选项，还得加上 option 的长度。</li><li>TypeofService (服务类型)：标示包传输优先级。总共 8 位，是由 3 个优先权位（不再使用），4 个 TOS 位，1 个固定的 0 组成。<br>4 个 TOS 位：最新延迟、最大吞吐量、最高可靠性、最小成本，只能 4 选一。</li><li>TotalLength（包长度）：整个 IP 包的长度，16 位，最大可以标示 65536 个字节，TotalLength-HeaderLength &#x3D; 数据长度。通过 HeaderLength 和 TotalLength 就可以知道数据的起始位置和结束位置。</li><li>Identifier（标识符）：网络中转发的 IP 报文的长度可以不同，但如果报文长度超过了数据链路所支持的最大长度，则报文就需要分割成若干个小的片段才能在链路上传输。比如以太网帧中数据最大长度（MTU）为 1500 字节，大于 MTU 的都会被分割，被分割的每个包都有相同的一个值，表示这是同一个 ip 包。</li><li>Flag（标志位）：标志字段在 IP 报头中占 3 位。</li></ol><ul><li>第 1 位作为保留；</li><li>第 2 位，分段，是否允许分片；（如果不允许分片，包超过了数据连路支持的最大长度，则丢弃该包，返回发送者一个 ICMP 错误）</li><li>第 3 位，更多分段。表示是否最后一个分片。</li></ul><p>当目的主机接收到一个 IP 数据报时，会首先查看该数据报的标识符，并且检查标志位的第 3 位是置 0 或置 1，以确定是否还有更多的分段。如果还有后续报文，接收主机则将接收到的报文放在缓存直到接收完所有具有相同标识符的数据报，然后再进行重组。</p><ol start="7"><li>FragmentedOffset（偏移量）：当某个 IP 大包分成多片时，各个分片是不按顺序达到目的地的，IP 包根据分片的偏移量进行重组包。（跟 TCP 原理一样）</li><li>（TimetoLive）生存时间：表示数据包经过的路由器个数。如果网络上有些路由器的路由表配置不合理，路由寻址可能会导致死循环，数据包会一直循环传输。IP 包发送的时候可以设置一个 TTL 值，比如 TTL&#x3D;64，没经过一个路由器 TTL 减 1，减到 0 还没到到目的地，路由器会抛弃这个 IP 包，并使用一个 ICMP 消息通知发送方。</li><li>Protocal（协议）：协议类型 1：ICMP，2：IGMP，6：TCP，17：UDP。</li><li>HeaderCheckSum（首部校验和）：校验 IP 协议头，判断 IP 协议头是否正确传输。</li><li>SourceAddress（源 IP）：请求方 IP</li><li>DistinationAddress（目的 IP）：响应方 IP</li><li>Options（可选字段）：IP 支持很多可选选项</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据包在七层模型的传输细节</title>
      <link href="/2023/12/21/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A0%E8%BE%93%E7%BB%86%E8%8A%82/"/>
      <url>/2023/12/21/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%A0%E8%BE%93%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="数据包在七层模型的传输细节"><a href="#数据包在七层模型的传输细节" class="headerlink" title="数据包在七层模型的传输细节"></a>数据包在七层模型的传输细节</h1><h2 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h2><p>数据自应用层产生，在应用层经过</p><h3 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h3><ul><li>按传输范围分：广域网wan、城域网can、<strong>局域网lan</strong>、个人区域网an</li><li>按网络拓补结构分：总线型网络、环状网络、星型网络</li></ul><h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h2><p>向app提供网络接口，直接向用户提供服务</p><h3 id="2-1-应用层工作内容"><a href="#2-1-应用层工作内容" class="headerlink" title="2.1 应用层工作内容"></a>2.1 应用层工作内容</h3><h3 id="2-2-应用层协议"><a href="#2-2-应用层协议" class="headerlink" title="2.2 应用层协议"></a>2.2 应用层协议</h3><ul><li>远程登录：telnet、ssh</li><li>文件传输: ftp、tftp、sftp</li><li>电子邮件：smtp、pop3、imap</li><li>网页浏览：http、https</li><li>网络管理：dns、dhcp</li></ul><h3 id="2-3-应用层如何提供功能服务："><a href="#2-3-应用层如何提供功能服务：" class="headerlink" title="2.3 应用层如何提供功能服务："></a>2.3 应用层如何提供功能服务：</h3><ul><li><a href="http%E5%8D%8F%E8%AE%AE">http&#x2F;https的概念和作用</a></li></ul><h2 id="三、表示层"><a href="#三、表示层" class="headerlink" title="三、表示层"></a>三、表示层</h2><h3 id="3-1-表示层的工作内容"><a href="#3-1-表示层的工作内容" class="headerlink" title="3.1 表示层的工作内容"></a>3.1 表示层的工作内容</h3><h3 id="3-2-表示层如何处理数据包"><a href="#3-2-表示层如何处理数据包" class="headerlink" title="3.2 表示层如何处理数据包"></a>3.2 表示层如何处理数据包</h3><h2 id="四、会话层"><a href="#四、会话层" class="headerlink" title="四、会话层"></a>四、会话层</h2><h3 id="4-1-会话层工作内容"><a href="#4-1-会话层工作内容" class="headerlink" title="4.1 会话层工作内容"></a>4.1 会话层工作内容</h3><h3 id="4-2-会话层如何处理数据包"><a href="#4-2-会话层如何处理数据包" class="headerlink" title="4.2 会话层如何处理数据包"></a>4.2 会话层如何处理数据包</h3><h2 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h2><h3 id="5-1-传输层工作内容"><a href="#5-1-传输层工作内容" class="headerlink" title="5.1 传输层工作内容"></a>5.1 传输层工作内容</h3><h3 id="5-2-传输层协议"><a href="#5-2-传输层协议" class="headerlink" title="5.2 传输层协议"></a>5.2 传输层协议</h3><h3 id="5-3-传输层如何处理数据包"><a href="#5-3-传输层如何处理数据包" class="headerlink" title="5.3 传输层如何处理数据包"></a>5.3 传输层如何处理数据包</h3><h2 id="六、网络层"><a href="#六、网络层" class="headerlink" title="六、网络层"></a>六、网络层</h2><h3 id="6-1-网络层工作内容"><a href="#6-1-网络层工作内容" class="headerlink" title="6.1 网络层工作内容"></a>6.1 网络层工作内容</h3><h3 id="6-2-网络层协议"><a href="#6-2-网络层协议" class="headerlink" title="6.2 网络层协议"></a>6.2 网络层协议</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><h4 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h4><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><h4 id="RARP协议"><a href="#RARP协议" class="headerlink" title="RARP协议"></a>RARP协议</h4><h3 id="6-3-网络层如何处理数据包"><a href="#6-3-网络层如何处理数据包" class="headerlink" title="6.3 网络层如何处理数据包"></a>6.3 网络层如何处理数据包</h3><h2 id="七、数据链路层"><a href="#七、数据链路层" class="headerlink" title="七、数据链路层"></a>七、数据链路层</h2><h3 id="7-1-数据链路层工作内容"><a href="#7-1-数据链路层工作内容" class="headerlink" title="7.1 数据链路层工作内容"></a>7.1 数据链路层工作内容</h3><h4 id="成帧"><a href="#成帧" class="headerlink" title="成帧"></a>成帧</h4><h4 id="帧纠错"><a href="#帧纠错" class="headerlink" title="帧纠错"></a>帧纠错</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="7-2-数据链路层协议"><a href="#7-2-数据链路层协议" class="headerlink" title="7.2 数据链路层协议"></a>7.2 数据链路层协议</h3><h3 id="7-3-数据链路层如何处理数据包"><a href="#7-3-数据链路层如何处理数据包" class="headerlink" title="7.3 数据链路层如何处理数据包"></a>7.3 数据链路层如何处理数据包</h3><h2 id="八、物理层"><a href="#八、物理层" class="headerlink" title="八、物理层"></a>八、物理层</h2><h3 id="8-1-物理层工作内容"><a href="#8-1-物理层工作内容" class="headerlink" title="8.1 物理层工作内容"></a>8.1 物理层工作内容</h3><p>物理层主要对数据链路层传下来的比特流进行透明传输，根据传输方式的不同，可以将物理层的传输概念分类</p><ul><li>按数据类型分：<a href="#%E4%BF%A1%E5%8F%B7%E8%BD%AC%E6%8D%A2">模拟信号和数字信号</a></li><li>按是否支持同时发送消息分：<a href="#%E5%8D%95%E5%B7%A5%E3%80%81%E5%8D%8A%E5%8F%8C%E5%B7%A5%E3%80%81%E5%8F%8C%E5%B7%A5">单工、半双工、双工</a></li><li>按传输方式分：<a href="#%E5%B9%B6%E8%A1%8C%E4%B8%B2%E8%A1%8C%E4%BC%A0%E8%BE%93">并行、串行</a></li><li>按编码方式分：<a href="https://www.cnblogs.com/ColaHua/p/12490529.html">归零编码、非归零编码、曼彻斯特编码、差分曼彻斯特编码</a><br><img src="/blogs/20200314085655.png" alt="物理层编码方式"></li></ul><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><h4 id="信号转换"><a href="#信号转换" class="headerlink" title="信号转换"></a>信号转换</h4><p>在物理层的传输介质中传输的信号共分为两种，模拟信号、数字信号，电话、有线电视属于模拟信号，电脑上网就用的是数字信号。</p><blockquote><p>modem（猫：调制解调器），最早的家用网络是通过电话线进行上网的（即模拟信号），需要使用modem将数字信号和模拟信号进行相互转换</p></blockquote><ul><li>调制：将数字信号转换为模拟信号</li><li>解调：将模拟信号转换为数字信号</li></ul><h4 id="并行-串行传输"><a href="#并行-串行传输" class="headerlink" title="并行&#x2F;串行传输"></a>并行&#x2F;串行传输</h4><ul><li>串行通信：将一个字符的二进制代码按从低位到高位顺序传输，传输中需要建立一个信道。</li><li>并行通信：将一个字符的二进制代码同时通过8条信道同时传输，每发送一个字符都需要建立8条信道，成本较高。</li></ul><h4 id="单工、半双工、双工"><a href="#单工、半双工、双工" class="headerlink" title="单工、半双工、双工"></a>单工、半双工、双工</h4><ul><li>单工通信：只能向一个方向发送信息，例如广播、电台、寻呼机</li><li>半双工通信：同一时刻只能有一个方向发送信息，例如对讲机</li><li>全双工通信：可以同时发送信息和接收信息，例如手机、电话</li></ul><h3 id="8-2-物理层协议"><a href="#8-2-物理层协议" class="headerlink" title="8.2 物理层协议"></a>8.2 物理层协议</h3><ul><li>点对点通信线路物理层协议</li><li>广播通信线路物理层协议<ul><li>有线通信线路（网线形式的网络）</li><li>无线通信线路（WIFI）</li></ul></li></ul><h3 id="8-3-物理层如何处理数据包"><a href="#8-3-物理层如何处理数据包" class="headerlink" title="8.3 物理层如何处理数据包"></a>8.3 物理层如何处理数据包</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux内核启动流程</title>
      <link href="/2023/12/19/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/12/19/linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="linux内核启动流程"><a href="#linux内核启动流程" class="headerlink" title="linux内核启动流程"></a>linux内核启动流程</h1><h2 id="一、硬件自检"><a href="#一、硬件自检" class="headerlink" title="一、硬件自检"></a>一、硬件自检</h2><ol><li>电源自检</li></ol><p>按下开关键后，电源启动，计算机会进行电源自检POST，主要是检查<strong>电源是否连接正常</strong>、<strong>电源开关是否正常</strong>、<strong>电源输出是否稳定</strong>，防止损坏计算机的硬件设备。<br>CPU状态：实模式，CS&#x3D;0xFFFF;IP&#x3D;0x0000，对应实际物理地址0xFFFF0(CS左移4位+IP)，指向装有BIOS的ROM</p><ol start="2"><li>BIOS自检</li></ol><p>电源自检通过，主板通电，读取ROM存放的BIOS程序，进行BIOS自检。BIOS负责管理和控制计算机硬件设备，本质上是一组”程序代码”。</p><p>BIOS作为CPU要进行处理的第一个“可执行程序”，也就是第一个“开机启动项”。其程序代码事先被刷入集成在主板的ROM芯片中，主要保存着系统设置程序、基本输入输出程序、开机上电自检程序和系统启动自举程序等</p><blockquote><p>ROM: 只读存储器，不需要供电也可保持数据不丢失。这点特性和内存有着鲜明的对比<br>现在一般用Flash闪存来代替ROM，由于ROM写入后就不能修改，改用Flash闪存后，既方便又能用专用程序即可修改其中代码</p></blockquote><p>BIOS自检内容：</p><p>硬件自检-&gt;初始化</p><p>自检对象：处理器、内存、硬盘、显卡、声卡、键盘、鼠标、显示器等</p><ol start="3"><li>选择引导设备、读取mbr并执行</li></ol><p>从第一设备中读取MBR，并且将程序放在0x7c00的内存地址</p><blockquote><p>磁盘：每个盘面划分成了一圈一圈的磁道，最外圈是0磁盘。然后每个磁盘又划分为了一个个小块，小块叫做扇区。扇区大小固定，是512个字节。</p></blockquote><blockquote><p>MBR在0盘0道0扇区上(最外层磁盘的最外围磁道的第一个扇区)，也就是该储存设备的第一个扇区(大小512个字节)。存放用于启动操作系统的引导程序代码，引导操作系统的启动</p></blockquote><p>mbr由三个部分组成：</p><ul><li><p>第一部分446个字节：主引导程序boot loader</p></li><li><p>第二部分64个字节：记录分区表</p><p>  硬盘可以分区，每个区可以安装不同的os，mbr必须知道将控制权转交给哪个操作系统。分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。</p><p>  每个主分区的16个字节，由6个部分组成：</p><ul><li>第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</li><li>第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</li><li>第5个字节：主分区类型。</li><li>第6-8个字节：主分区最后一个扇区的物理位置。</li><li>第9-12字节：该主分区第一个扇区的逻辑地址。</li><li>第13-16字节：主分区的扇区总数，决定了这个主分区的长度，一个主分区的扇区总数最多不超过2的32次方。</li></ul><p>  当主引导程序将硬盘的第一个扇区中读取到的操作系统引导程序代码(512 个字节的内容)，加载(原封不动地复制)到计算机内存0x7c00这个位置。这个过程需要依靠硬盘控制器和指令集来完成。</p></li><li><p>第三个部分占2个字节：主引导记录的签名（0x55和0xAA）,如果这512字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。如果到最后还是没找到符合条件的，直接报出一个无启动区的error。</p></li></ul><h4 id="0x7c00是什么地址？"><a href="#0x7c00是什么地址？" class="headerlink" title="0x7c00是什么地址？"></a>0x7c00是什么地址？</h4><p>0x7C00这个地址，第一次出现于IBM PC 5150电脑，IBM PC 5150是x86（32位）IBM PC&#x2F;AT系列的老祖宗，使用了intel 8088芯片，后人一直沿用这个地址以保持兼容。</p><p>IBM PC 5150电脑的操作系统是86-DOS，它最少需要32KB的内存，32KB&#x3D;32 * 1024B &#x3D; 32768B &#x3D; 0x8000B, 由于内存地址是从0x0000开始的，32位末地址是0x8000 -1&#x3D;0x7FFF所以32KB的内存地址是0x0000～0x7FFF</p><p>现在又知主引导记录需要512字节，其本身引导程序的堆栈&#x2F;数据区域也至少需要512 字节</p><p>0x7FFF -512 -512 + 1&#x3D;0x7C00，这样就得出0x7C00这个地址了。</p><p>计算机启动会后，内存布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+——————— 0×0</span><br><span class="line">| Interrupts vectors（中断向量表）</span><br><span class="line">+——————— 0×400</span><br><span class="line">| BIOS data area（BIOS的数据区域）</span><br><span class="line">+——————— 0×5??</span><br><span class="line">| OS load area（操作系统加载区域）</span><br><span class="line">+——————— 0x7C00</span><br><span class="line">| Boot sector（引导区域）</span><br><span class="line">+——————— 0x7E00</span><br><span class="line">| Boot data/stack（引导数据/堆栈）</span><br><span class="line">+——————— 0x7FFF</span><br><span class="line">| (not used) </span><br><span class="line">+——————— (…)</span><br></pre></td></tr></table></figure><ol start="5"><li>启动操作系统</li></ol><p>跳转到c程序或是汇编程序，这时候就是操作系统的代码范畴了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列思想和实现</title>
      <link href="/2023/12/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2023/12/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><ul><li>producer：消息生产者，多个，负责将消息发送到消息队列</li><li>broker：消息处理中心，包含多个消息队列，负责存储消息、确认、重试等</li><li>consumer：消息消费者，从消息队列获取消息</li></ul><h2 id="二、消息队列模式"><a href="#二、消息队列模式" class="headerlink" title="二、消息队列模式"></a>二、消息队列模式</h2><ul><li>点对点模式</li></ul><p>多个producer向同一个broker的同一个queue发送消息，一个具体的消息只能由一个consumer消费</p><ul><li>发布&#x2F;订阅模式</li></ul><p>单个消息可以被多个consumer消费</p><h2 id="三、RocketMQ简要概述"><a href="#三、RocketMQ简要概述" class="headerlink" title="三、RocketMQ简要概述"></a>三、RocketMQ简要概述</h2><p>RocketMQ 是阿里开源的消息中间件，纯Java开发，高性能、高可靠、高实时、适合大规模分布式系统应用。</p><p>RocketMQ 思路起源于 Kafka，对消息的可靠传输及事务性做了优化</p><h3 id="3-1-重要概念"><a href="#3-1-重要概念" class="headerlink" title="3.1 重要概念"></a>3.1 重要概念</h3><ul><li>Name 服务器（NameServer）：充当注册中心，类似 Kafka 的 Zookeeper。</li><li>Broker: 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。</li><li>主题（Topic）：消息的第一级类型，一条消息必须有一个 Topic。</li><li>子主题（Tag）：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。</li><li>分组（Group）：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。</li><li>队列（Queue）：可以类比 Kafka 的分区 Partition。</li></ul><h3 id="3-2-工作原理"><a href="#3-2-工作原理" class="headerlink" title="3.2 工作原理"></a>3.2 工作原理</h3><p>RocketMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。</p><p>为了提高并发能力，一个 Topic 包含多个 Queue，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。</p><p>RocketMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。</p><p>消费 Queue 的过程中，通过偏移量记录消费的位置。<br><img src="/blogs/640.png" alt="rocket消息偏移量"></p><h3 id="3-3-架构"><a href="#3-3-架构" class="headerlink" title="3.3 架构"></a>3.3 架构</h3><p>RocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。</p><p>Broker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。</p><p>如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。</p><p><img src="/blogs/640.jpg" alt="rocketmq的queue"></p><p>Broker 通过集群部署，并且提供了 master&#x2F;slave 的结构，slave 定时从 master 同步数据（同步刷盘或者异步刷盘），如果 master 宕机，则 slave 提供消费服务，但是不能写入消息。</p><h2 id="四、部署和使用rocketMQ"><a href="#四、部署和使用rocketMQ" class="headerlink" title="四、部署和使用rocketMQ"></a>四、部署和使用rocketMQ</h2><h3 id="4-1-环境搭建"><a href="#4-1-环境搭建" class="headerlink" title="4.1 环境搭建"></a>4.1 环境搭建</h3><h3 id="4-2-java代码实现"><a href="#4-2-java代码实现" class="headerlink" title="4.2 java代码实现"></a>4.2 java代码实现</h3><h3 id="4-3-成果"><a href="#4-3-成果" class="headerlink" title="4.3 成果"></a>4.3 成果</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程间通信</title>
      <link href="/2023/12/12/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/12/12/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux进程通信"><a href="#Linux进程通信" class="headerlink" title="Linux进程通信"></a>Linux进程通信</h1><p>不同进程的地址空间是隔离的。A 进程的地址 0x4000 和 B 进程的 0x4000 之间没有任何关系。如果要进行进程间通信，最常用的做法是让进程之间通过 127.0.0.1 或者是 Unix Domain Socket 等本机网络手段进行数据的传输。这个方案在传输的数据量较小的时候工作是很不错的。但如果进程间想共享的数据特别大，比如说几个 GB，那如果使用网络 IO 方案的话，就会涉及到大量的内存拷贝的开销，导致比较低的程序性能。这时可以采用进程间**<u><em>共享内存</em></u>**的方法来在通信时避免内存拷贝。</p><h2 id="一、共享内存的使用方式"><a href="#一、共享内存的使用方式" class="headerlink" title="一、共享内存的使用方式"></a>一、共享内存的使用方式</h2><p>共享内存发送方进程的开发基本过程是调用 memfd_create 创建一个内存文件。然后通过 mmap 系统调用为这个内存文件申请一块<strong>共享内存</strong>。然后这个内存文件就可以写入数据了。最后把这个文件的句柄通过 Unix Domain Socket 的方式给接收方进程发送过去。</p><p>下面是发送方的核心代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建内存文件</span></span><br><span class="line"> fd = memfd_create(<span class="string">&quot;Server memfd&quot;</span>, ...);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 为内存文件申请 MAP_SHARED 类型的内存</span></span><br><span class="line"> shm = mmap(<span class="literal">NULL</span>, shm_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 向共享内存中写入数据</span></span><br><span class="line"> <span class="built_in">sprintf</span>(shm, <span class="string">&quot;这段内容是保存在共享内存里的，接收方和发送方都能根据自己的fd访问到这块内容&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 把共享内存文件的句柄给接收方进程发送过去</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span>;</span></span><br><span class="line"> *((<span class="type">int</span> *) CMSG_DATA(CMSG_FIRSTHDR(&amp;msgh))) = fd;</span><br><span class="line"> sendmsg(conn, &amp;msgh, <span class="number">0</span>);</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享内存接收方的工作过程是先用 Unix Domain Socket 连接上服务器，然后使用 recvmsg 就可以收到发送方发送过来的文件句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 Unix Domain Socket 连接发送方</span></span><br><span class="line">    connect(conn, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un));</span><br><span class="line">    <span class="comment">// 通过连接取出发送方发送过来的内存文件句柄</span></span><br><span class="line">    <span class="type">int</span> size = recvmsg(conn, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">    fd = *((<span class="type">int</span> *) CMSG_DATA(cmsgh));</span><br><span class="line">    <span class="comment">// 读取共享文件中的内容</span></span><br><span class="line">    shm = mmap(<span class="literal">NULL</span>, shm_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存中的文件内容是: %s\n&quot;</span>, shm);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样这两个进程都各自有一个文件句柄，在底层上是指向同一个内存文件的。这样就实现了发送方和接收方之间的内存文件共享了。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/BBjAFF4hcwpfibKtKUONu125vkLvMX4gxsghs13X2ueOHsvh0O0O3JSdby9EpDbK2giaA5IN0ib4D3AdXsjw8GTWA/640?wx_fmt=png&from=appmsg" alt="img"></p><p>接下来深入地分析 memfd_create、 mmap、以及 Unix Domain socket sendmsg 和 recvmsg 的底层工作原理，来看看它们是如何配合来实现跨进程共享内存的。</p><h2 id="二、共享内存文件原理"><a href="#二、共享内存文件原理" class="headerlink" title="二、共享内存文件原理"></a>二、共享内存文件原理</h2><p>在发送方发送文件之前，需要先通过 memfd_create 来创建一个内存文件，然后再使用 mmap 为其分配内存。</p><h3 id="2-1-创建内存文件"><a href="#2-1-创建内存文件" class="headerlink" title="2.1 创建内存文件"></a>2.1 创建内存文件</h3><p>其中 memfd_create 函数是一个系统调用。内核中它的主要逻辑有两个，一是调用 get_unused_fd_flags 申请一个没使用过的文件句柄，二是调用 shmem_file_setup 创建一个共享内存文件。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/BBjAFF4hcwpfibKtKUONu125vkLvMX4gxS5xjbLGFZ5ZiaDmdF9iccFUwPKGc3RpdYOzRhALCcaORtS8zxflCyByw/640?wx_fmt=png&from=appmsg" alt="img"></p><p> memfd_create 的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:mm/memfd.c</span></span><br><span class="line">SYSCALL_DEFINE2(memfd_create,<span class="type">const</span> <span class="type">char</span> __user *, uname, <span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 申请一个未使用过的文件句柄</span></span><br><span class="line"> fd = get_unused_fd_flags((flags &amp; MFD_CLOEXEC) ? O_CLOEXEC : <span class="number">0</span>);</span><br><span class="line"> <span class="comment">// 创建一个共享内存的文件</span></span><br><span class="line"> file = shmem_file_setup(name, <span class="number">0</span>, VM_NORESERVE);</span><br><span class="line"></span><br><span class="line"> fd_install(fd, file);</span><br><span class="line"> <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在 shmem_file_setup 函数中又调用了 __shmem_file_setup。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file:mm/shmem.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">shmem_file_setup</span>(<span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, ...)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 申请一个 inode</span></span><br><span class="line"> inode = shmem_get_inode(mnt-&gt;mnt_sb, <span class="literal">NULL</span>, S_IFREG | S_IRWXUGO, <span class="number">0</span>, flags);</span><br><span class="line"> inode-&gt;i_flags |= i_flags;</span><br><span class="line"> inode-&gt;i_size = size;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 创建一个文件</span></span><br><span class="line"> res = alloc_file_pseudo(inode, mnt, name, O_RDWR,</span><br><span class="line">    &amp;shmem_file_operations);</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>磁盘文件在内核的实现中是由 inode 和 struct file 对象一起组成的。共享内存文件也一样，__shmem_file_setup 中就是先申请了一个 inode，然后再调用 alloc_file_pseudo 创建一个文件。值得注意的是，这个文件并非是磁盘上的文件，而只是在内存里的。</p><h3 id="2-2-mmap申请内存"><a href="#2-2-mmap申请内存" class="headerlink" title="2.2 mmap申请内存"></a>2.2 mmap申请内存</h3><p><code>mmap</code>也是一个系统调用，开篇处调用它的时候传入的第三个<code>flag</code>参数是<code>MAP_SHARED</code>。这表示的是要通过<code>mmap</code>申请一块跨进程可共享的内存出来。<code>mmap</code>的实现入口在 arch&#x2F;x86&#x2F;kernel&#x2F;sys_x86_64.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:arch/x86/kernel/sys_x86_64.c</span></span><br><span class="line">SYSCALL_DEFINE6(mmap, <span class="type">unsigned</span> <span class="type">long</span>, addr, ...)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> ksys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的这个函数的调用链路如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(mmap</span><br><span class="line">-&gt; ksys_mmap_pgoff</span><br><span class="line">---&gt; vm_mmap_pgoff</span><br><span class="line">------&gt; do_mmap_pgoff</span><br><span class="line">--------&gt; do_mmap</span><br></pre></td></tr></table></figure><p>在 do_mmap 函数中，对输入的 MAP_SHARED 进行了处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:mm/mmap.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> prot,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">vm_flags_t</span> vm_flags,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> *populate,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> list_head *uf)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果包含 MAP_SHARED，则对要申请的虚拟内存设置一个 VM_SHARED</span></span><br><span class="line"> <span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">  <span class="keyword">case</span> MAP_SHARED:</span><br><span class="line">  <span class="keyword">case</span> MAP_SHARED_VALIDATE:</span><br><span class="line">   vm_flags |= VM_SHARED | VM_MAYSHARE; </span><br><span class="line">   ... </span><br><span class="line"> &#125; </span><br><span class="line"> ... </span><br><span class="line"></span><br><span class="line"> addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 flag 包含了 MAP_SHARED，则对要申请的虚拟内存设置一个 VM_SHARED。该标记指明的是要申请一个可以跨进程共享的内存块。接下来进入 mmap_region 中申请虚拟内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:mm/mmap.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">mmap_region</span><span class="params">(<span class="keyword">struct</span> file *file, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 申请虚拟内存vma</span></span><br><span class="line"> vma = vm_area_alloc(mm);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// vma初始化</span></span><br><span class="line"> vma-&gt;vm_start = addr;</span><br><span class="line"> vma-&gt;vm_end = addr + len;</span><br><span class="line"> vma-&gt;vm_flags = vm_flags;</span><br><span class="line"> vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);</span><br><span class="line"> vma-&gt;vm_pgoff = pgoff;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加入到进程的虚拟内存 vma 链表中来</span></span><br><span class="line"> vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程的虚拟内存地址空间在内核底层中就是由这样一个个的 vma 来组成的。每一个 vma 都声明的是进程虚拟地址中的某一段地址范围已经分配出去了。在 mmap_region 函数中申请了 vma，并在内核中将其管理了起来。</p><p>这里注意我们在申请共享内存的时候，给 vma 是带了 VM_SHARED 标记的。带了这个标记的 vma和普通的虚拟内存不一样。后面在发生缺页中断申请物理内存的时候，在不同的进程间是可以对应到同一块物理内存的。所以可以实现进程间的共享。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/BBjAFF4hcwpfibKtKUONu125vkLvMX4gxPt0XSxtJ5KM6XoyTNGx2oY4lCKGcQ3eBxfRufjnx0Envfg0PuXbp0A/640?wx_fmt=png&from=appmsg" alt="img"></p><p>所以真正让进程之间可以共享内存的是这个带 VM_SHARED 的 vma。</p><h2 id="三、发送方发送文件句柄"><a href="#三、发送方发送文件句柄" class="headerlink" title="三、发送方发送文件句柄"></a>三、发送方发送文件句柄</h2><p>发送方在使用 memfd_create 创建出来内存文件，并用 mmap 为其申请可跨进程共享的内存后。接着就可以通过 Unix Domain Socket 中对应的 sendmsg 方法将这个共享内存文件的句柄发送出来。如下是发送的代码示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">send_fd</span><span class="params">(<span class="type">int</span> conn, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msgh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把文件句柄放到消息中来</span></span><br><span class="line">    *((<span class="type">int</span> *) CMSG_DATA(CMSG_FIRSTHDR(&amp;msgh))) = fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送出去</span></span><br><span class="line">    sendmsg(conn, &amp;msgh, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendmsg 又是一个内核提供的系统调用，它位于 net&#x2F;socket.c 文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/socket.c</span></span><br><span class="line">SYSCALL_DEFINE3(sendmsg, <span class="type">int</span>, fd, <span class="keyword">struct</span> user_msghdr __user *, msg, <span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> __sys_sendmsg(fd, msg, flags, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的调用路径如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(sendmsg, ...)</span><br><span class="line">-&gt; __sys_sendmsg</span><br><span class="line">---&gt; ___sys_sendmsg</span><br><span class="line">-----&gt; ____sys_sendmsg</span><br><span class="line">-------&gt; sock_sendmsg</span><br><span class="line">---------&gt; sock_sendmsg_nosec</span><br><span class="line">-----------&gt; unix_stream_sendmsg</span><br></pre></td></tr></table></figure><p>在 unix_stream_sendmsg 中执行了真正的发送。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/unix/af_unix.c </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unix_stream_sendmsg</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *msg, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 把文件描述符指向的文件信息复制到 scm_cookie 中</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">scm_cookie</span> <span class="title">scm</span>;</span></span><br><span class="line"> scm_send(sock, msg, &amp;scm, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不断构建数据包发送，直到发送完毕</span></span><br><span class="line">    <span class="keyword">while</span> (sent &lt; len) &#123;</span><br><span class="line">     <span class="comment">// 申请一块缓存区</span></span><br><span class="line">     skb = sock_alloc_send_pskb(sk, size - data_len, data_len,</span><br><span class="line">        msg-&gt;msg_flags &amp; MSG_DONTWAIT, &amp;err,</span><br><span class="line">        get_order(UNIX_SKB_FRAGS_SZ));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 拷贝数据到 skb</span></span><br><span class="line">     err = unix_scm_to_skb(&amp;scm, skb, !fds_sent);</span><br><span class="line">     err = skb_copy_datagram_from_iter(skb, <span class="number">0</span>, &amp;msg-&gt;msg_iter, size);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 直接把 skb 放到对端的接收队列中</span></span><br><span class="line">     skb_queue_tail(&amp;other-&gt;sk_receive_queue, skb);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//发送完毕回调</span></span><br><span class="line">  other-&gt;sk_data_ready(other);</span><br><span class="line">  sent += size;</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 unix_stream_sendmsg 中申请了个 skb 缓存区，然后把<strong>要发送的文件句柄</strong>等数据都塞到里面，最后调用 skb_queue_tail 直接把 skb 放到 Unix Domain Socket 连接另一端的接收队列中了。</p><p>这里注意文件句柄只有在当前进程内才是有意义的。如果直接发送 fd 出去，接收方是没有办法使用的。所以在 scm_send 函数中，重要的逻辑<strong>是把 fd 对应的 struct file 的指针给找了出来，放到待发送的数据里面了</strong>。只有 file 这种内核级的对象接收方才能使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scm_send</span><br><span class="line">-&gt; __scm_send</span><br><span class="line">---&gt; scm_fp_copy</span><br></pre></td></tr></table></figure><p>在 scm_fp_copy 中根据 fd 把 file 给找了出来。它的指针会被放到发送数据中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/core/scm.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">scm_fp_copy</span><span class="params">(<span class="keyword">struct</span> cmsghdr *cmsg, <span class="keyword">struct</span> scm_fp_list **fplp)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">//把每一个要发送的 fd 对应的 file 给找出来</span></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; num; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">int</span> fd = fdp[i];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || !(file = fget_raw(fd)))</span><br><span class="line">   <span class="keyword">return</span> -EBADF;</span><br><span class="line">  *fpp++ = file;</span><br><span class="line">  fpl-&gt;count++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、接收方接收文件"><a href="#四、接收方接收文件" class="headerlink" title="四、接收方接收文件"></a>四、接收方接收文件</h3><p>接下来接收方就可以通过 recvmsg 来接收发送方发送过来的文件了。recvmsg 系统会调用到 unix_stream_read_generic 中，然后在这个函数中把 skb 给取出来。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/BBjAFF4hcwpfibKtKUONu125vkLvMX4gxHku9TqiaPZeMFIr9E10kJuTrruiaxJbSJF9ibGgeyENYYhEeuCf9CN03Q/640?wx_fmt=png&from=appmsg" alt="img"></p><p>下面是接收函数核心 unix_stream_read_generic 的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/unix/af_unix.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unix_stream_read_generic</span><span class="params">(<span class="keyword">struct</span> unix_stream_read_state *state,</span></span><br><span class="line"><span class="params">        <span class="type">bool</span> freezable)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 拿出一个 skb</span></span><br><span class="line">  last = skb = skb_peek(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">if</span> (state-&gt;msg)</span><br><span class="line">  scm_recv(sock, state-&gt;msg, &amp;scm, flags);</span><br><span class="line"> <span class="keyword">return</span> copied ? : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 skb 拿出来后，还需要调用 scm_recv 来把 skb 中包含的文件给找出来。在 scm_recv 中调用 scm_detach_fds。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:net/core/scm.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">scm_detach_fds</span><span class="params">(<span class="keyword">struct</span> msghdr *msg, <span class="keyword">struct</span> scm_cookie *scm)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fdmax; i++) &#123;</span><br><span class="line">  err = receive_fd_user(scm-&gt;fp-&gt;fp[i], cmsg_data + i, o_flags);</span><br><span class="line">  <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 scm-&gt;fp-&gt;fp[i] 中包含的是发送方发送过来的 struct file 指针。这样文件就取出来了。当然 struct file 是个内核态的对象，用户没有办法使用。所以还需要再为其在新的进程中申请一个文件句柄，然后返回。本文来自公众号「开发内功修炼」。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:fs/file.c</span></span><br><span class="line"><span class="type">int</span> __receive_fd(<span class="keyword">struct</span> file *file, <span class="type">int</span> __user *ufd, <span class="type">unsigned</span> <span class="type">int</span> o_flags)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//申请一个新的文件描述符</span></span><br><span class="line"> new_fd = get_unused_fd_flags(o_flags);</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//关联文件</span></span><br><span class="line"> fd_install(new_fd, get_file(file));</span><br><span class="line"> <span class="keyword">return</span> new_fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>共享内存发送方进程的开发过程基本分 memfd_create 创建内存文件、mmap 申请共享内存、Unix Domain Socket 发送文件句柄三步。</p><ul><li>第一步，memfd_create 系统调用的主要逻辑有两个，一是调用 get_unused_fd_flags 申请一个没使用过的文件句柄，二是调用 shmem_file_setup 创建一个共享内存文件。</li><li>第二步，mmap 系统调用在调用它的时候传入的第三个 flag 参数是 MAP_SHARED，该参数是申请一块跨进程可共享访问的物理内存。</li><li>第三步，接着通过 Unix Domain Socket 中对应的 sendmsg 方法将这个共享内存文件的句柄发送出去。在发送时，把文件句柄对应的 struct file 指针找到并放到要封装的 skb 数据包中了。</li></ul><p>接收方进程的主要实现原理是 recvmsg 系统调用。在这个系统调用中，内核会把发送方发送过来的 struct file 指针取出来，然后再在当前进程下为其申请一个新的文件句柄。这个文件句柄返回给用户进程后，用户进程就可以用它来和另外一个进程共享地访问同一块内存了。</p><p>总体来看，共享内存本质上共享的是内核对象 struct file，通过在不同的进程之间使用同一个 struct file 来实现的共享。当然也得需要在虚拟内存对象 vma 带上 VM_SHARED 标记来支持。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python入门语法</title>
      <link href="/2023/12/12/python%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/12/12/python%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="python入门语法"><a href="#python入门语法" class="headerlink" title="python入门语法"></a>python入门语法</h1><h2 id="一、类的定义"><a href="#一、类的定义" class="headerlink" title="一、类的定义"></a>一、类的定义</h2><p>_foo，单下划线开头： protected 类型的变量或方法，只允许其本身与子类进行访问，不能用于 from module import *<br>__foo，双下划线：私有类型(private)的变量或方法, 只允许这个类本身进行访问<br>foo，正常的 public 变量<br>def __foo__(): # 使用__xx__定义的一般是保留的，如__init()__，与c的关键字类似，不建议在日常业务或使用中写这种风格的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TClass</span>:</span><br><span class="line">    _foo = <span class="number">0</span>       <span class="comment"># 单下划线开头： protected 类型的变量或方法，只允许其本身与子类进行访问，不能用于 from module import *</span></span><br><span class="line">    __foo = <span class="number">0</span>      <span class="comment"># 双下划线：私有类型(private)的变量或方法, 只允许这个类本身进行访问</span></span><br><span class="line">    foo = <span class="number">0</span>   <span class="comment"># 正常的 public 变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__foo__</span>(): <span class="comment"># 使用__xx__定义的一般是保留的，如__init()__，与c的关键字类似，不建议在日常业务或使用中写这种风格的代码</span></span><br><span class="line">        <span class="comment"># todo</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="二、类的继承"><a href="#二、类的继承" class="headerlink" title="二、类的继承"></a>二、类的继承</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TClass</span>(A, B): <span class="comment"># 支持多继承</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="python的字典"><a href="#python的字典" class="headerlink" title="python的字典"></a>python的字典</h2><p>KV类型的数据结构，使用案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">    (<span class="string">&quot;12944551388&quot;</span>, <span class="number">16</span>),(<span class="string">&quot;12936786244&quot;</span>, <span class="number">12</span>),(<span class="string">&quot;12944540156&quot;</span>, <span class="number">12</span>),(<span class="string">&quot;12944547158&quot;</span>, <span class="number">10</span>),(<span class="string">&quot;12936764315&quot;</span>, <span class="number">8</span>),(<span class="string">&quot;12944555064&quot;</span>, <span class="number">8</span>),(<span class="string">&quot;12936773718&quot;</span>, <span class="number">7</span>),(<span class="string">&quot;12944546248&quot;</span>, <span class="number">7</span>),</span><br><span class="line">    (<span class="string">&quot;12944553664&quot;</span>, <span class="number">7</span>),(<span class="string">&quot;12944553664&quot;</span>, <span class="number">6</span>),(<span class="string">&quot;12936764315&quot;</span>, <span class="number">5</span>),(<span class="string">&quot;12936769236&quot;</span>, <span class="number">4</span>),(<span class="string">&quot;12944548117&quot;</span>, <span class="number">4</span>),(<span class="string">&quot;12936766915&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12936783342&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12944540156&quot;</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="string">&quot;12944542490&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12944543864&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12944553778&quot;</span>, <span class="number">3</span>),(<span class="string">&quot;12936786244&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;12944538208&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944538637&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944540736&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944546248&quot;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">&quot;12944549839&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944555064&quot;</span>, <span class="number">1</span>),(<span class="string">&quot;12944555064&quot;</span>, <span class="number">1</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> result:</span><br><span class="line">        result[key] += value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result[key] = value</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
